/*!
 * excalibur - 0.27.0 - 2022-7-8
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2022 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ex"] = factory();
	else
		root["ex"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 4662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(3430);
var entryUnbind = __webpack_require__(8791);

module.exports = entryUnbind('Array', 'sort');


/***/ }),

/***/ 8343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4769);
var path = __webpack_require__(9276);

module.exports = path.Object.keys;


/***/ }),

/***/ 7111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var tryToString = __webpack_require__(9821);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(5052);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(905);
var toAbsoluteIndex = __webpack_require__(3231);
var lengthOfArrayLike = __webpack_require__(9646);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ 9794:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toAbsoluteIndex = __webpack_require__(3231);
var lengthOfArrayLike = __webpack_require__(9646);
var createProperty = __webpack_require__(2324);

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ 3867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySlice = __webpack_require__(9794);

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;


/***/ }),

/***/ 7079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);
var isCallable = __webpack_require__(6733);
var classofRaw = __webpack_require__(7079);
var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(8270);
var ownKeys = __webpack_require__(4826);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var definePropertyModule = __webpack_require__(1787);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 5762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var definePropertyModule = __webpack_require__(1787);
var createPropertyDescriptor = __webpack_require__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2324:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(9310);
var definePropertyModule = __webpack_require__(1787);
var createPropertyDescriptor = __webpack_require__(5358);

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 4768:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var definePropertyModule = __webpack_require__(1787);
var makeBuiltIn = __webpack_require__(6039);
var defineGlobalProperty = __webpack_require__(8400);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 8400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 9563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var tryToString = __webpack_require__(9821);

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ 7400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(598);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var UA = __webpack_require__(598);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var userAgent = __webpack_require__(598);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(598);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 8791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var uncurryThis = __webpack_require__(5968);

module.exports = function (CONSTRUCTOR, METHOD) {
  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);
};


/***/ }),

/***/ 3837:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var getOwnPropertyDescriptor = (__webpack_require__(7933).f);
var createNonEnumerableProperty = __webpack_require__(5762);
var defineBuiltIn = __webpack_require__(4768);
var defineGlobalProperty = __webpack_require__(8400);
var copyConstructorProperties = __webpack_require__(7081);
var isForced = __webpack_require__(6541);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 7188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(7188);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 1805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var hasOwn = __webpack_require__(8270);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 5968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(7188);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isCallable = __webpack_require__(6733);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5300:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(7111);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 8270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);
var toObject = __webpack_require__(2991);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 4394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var fails = __webpack_require__(4229);
var createElement = __webpack_require__(2635);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 9337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);
var fails = __webpack_require__(4229);
var classof = __webpack_require__(7079);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 8511:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);
var isCallable = __webpack_require__(6733);
var store = __webpack_require__(5353);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 6407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(8694);
var global = __webpack_require__(9859);
var uncurryThis = __webpack_require__(5968);
var isObject = __webpack_require__(5052);
var createNonEnumerableProperty = __webpack_require__(5762);
var hasOwn = __webpack_require__(8270);
var shared = __webpack_require__(5353);
var sharedKey = __webpack_require__(4399);
var hiddenKeys = __webpack_require__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 6733:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 6541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);
var isCallable = __webpack_require__(6733);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 4231:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 9395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(1333);
var isCallable = __webpack_require__(6733);
var isPrototypeOf = __webpack_require__(1321);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 9646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(4237);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 6039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);
var isCallable = __webpack_require__(6733);
var hasOwn = __webpack_require__(8270);
var DESCRIPTORS = __webpack_require__(7400);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(1805).CONFIGURABLE);
var inspectSource = __webpack_require__(8511);
var InternalStateModule = __webpack_require__(6407);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 917:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 3839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(6358);
var fails = __webpack_require__(4229);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isCallable = __webpack_require__(6733);
var inspectSource = __webpack_require__(8511);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 1787:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var IE8_DOM_DEFINE = __webpack_require__(4394);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(7137);
var anObject = __webpack_require__(1176);
var toPropertyKey = __webpack_require__(9310);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var call = __webpack_require__(266);
var propertyIsEnumerableModule = __webpack_require__(9195);
var createPropertyDescriptor = __webpack_require__(5358);
var toIndexedObject = __webpack_require__(905);
var toPropertyKey = __webpack_require__(9310);
var hasOwn = __webpack_require__(8270);
var IE8_DOM_DEFINE = __webpack_require__(4394);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8151:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 140:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);
var hasOwn = __webpack_require__(8270);
var toIndexedObject = __webpack_require__(905);
var indexOf = (__webpack_require__(9540).indexOf);
var hiddenKeys = __webpack_require__(5977);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(266);
var isCallable = __webpack_require__(6733);
var isObject = __webpack_require__(5052);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(1333);
var uncurryThis = __webpack_require__(5968);
var getOwnPropertyNamesModule = __webpack_require__(8151);
var getOwnPropertySymbolsModule = __webpack_require__(894);
var anObject = __webpack_require__(1176);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);

module.exports = global;


/***/ }),

/***/ 8885:
/***/ ((module) => {

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 4399:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(3036);
var uid = __webpack_require__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var defineGlobalProperty = __webpack_require__(8400);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(4231);
var store = __webpack_require__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.23.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 3231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3329);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(9337);
var requireObjectCoercible = __webpack_require__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 3329:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(917);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 4237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3329);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(8885);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(266);
var isObject = __webpack_require__(5052);
var isSymbol = __webpack_require__(9395);
var getMethod = __webpack_require__(5300);
var ordinaryToPrimitive = __webpack_require__(2914);
var wellKnownSymbol = __webpack_require__(95);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 9310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(2066);
var isSymbol = __webpack_require__(9395);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3326:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(1589);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 9821:
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 1441:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5968);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 7137:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var fails = __webpack_require__(4229);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 95:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var shared = __webpack_require__(3036);
var hasOwn = __webpack_require__(8270);
var uid = __webpack_require__(1441);
var NATIVE_SYMBOL = __webpack_require__(3839);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3430:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(3103);
var uncurryThis = __webpack_require__(5968);
var aCallable = __webpack_require__(7111);
var toObject = __webpack_require__(2991);
var lengthOfArrayLike = __webpack_require__(9646);
var deletePropertyOrThrow = __webpack_require__(9563);
var toString = __webpack_require__(3326);
var fails = __webpack_require__(4229);
var internalSort = __webpack_require__(3867);
var arrayMethodIsStrict = __webpack_require__(6038);
var FF = __webpack_require__(2671);
var IE_OR_EDGE = __webpack_require__(8506);
var V8 = __webpack_require__(6358);
var WEBKIT = __webpack_require__(9811);

var test = [];
var un$Sort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(3103);
var toObject = __webpack_require__(2991);
var nativeKeys = __webpack_require__(5632);
var fails = __webpack_require__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 1388:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://./Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 7379:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\r\n#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}", "",{"version":3,"sources":["webpack://./Util/Toaster.css"],"names":[],"mappings":";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB","sourcesContent":["\r\n#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2609:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 272:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ActionContext": () => (/* reexport */ ActionContext),
  "ActionQueue": () => (/* reexport */ ActionQueue),
  "ActionSequence": () => (/* reexport */ ActionSequence),
  "ActionsComponent": () => (/* reexport */ ActionsComponent),
  "ActionsSystem": () => (/* reexport */ ActionsSystem),
  "ActivateEvent": () => (/* reexport */ ActivateEvent),
  "Actor": () => (/* reexport */ Actor),
  "AddedComponent": () => (/* reexport */ AddedComponent),
  "AddedEntity": () => (/* reexport */ AddedEntity),
  "AffineMatrix": () => (/* reexport */ AffineMatrix),
  "Animation": () => (/* reexport */ Animation),
  "AnimationDirection": () => (/* reexport */ AnimationDirection),
  "AnimationStrategy": () => (/* reexport */ AnimationStrategy),
  "ArcadeSolver": () => (/* reexport */ ArcadeSolver),
  "AudioContextFactory": () => (/* reexport */ AudioContextFactory),
  "Axis": () => (/* reexport */ Axis),
  "BaseAlign": () => (/* reexport */ BaseAlign),
  "Blink": () => (/* reexport */ Blink),
  "BodyComponent": () => (/* reexport */ BodyComponent),
  "BoundingBox": () => (/* reexport */ BoundingBox),
  "BroadphaseStrategy": () => (/* reexport */ BroadphaseStrategy),
  "BrowserComponent": () => (/* reexport */ BrowserComponent),
  "BrowserEvents": () => (/* reexport */ BrowserEvents),
  "Camera": () => (/* reexport */ Camera),
  "Canvas": () => (/* reexport */ Canvas),
  "Circle": () => (/* reexport */ Circle),
  "CircleCollider": () => (/* reexport */ CircleCollider),
  "Class": () => (/* reexport */ Class),
  "Clock": () => (/* reexport */ Clock),
  "ClosestLine": () => (/* reexport */ ClosestLine),
  "ClosestLineJumpTable": () => (/* reexport */ ClosestLineJumpTable),
  "Collider": () => (/* reexport */ Collider),
  "ColliderComponent": () => (/* reexport */ ColliderComponent),
  "CollisionContact": () => (/* reexport */ CollisionContact),
  "CollisionEndEvent": () => (/* reexport */ CollisionEndEvent),
  "CollisionGroup": () => (/* reexport */ CollisionGroup),
  "CollisionGroupManager": () => (/* reexport */ CollisionGroupManager),
  "CollisionJumpTable": () => (/* reexport */ CollisionJumpTable),
  "CollisionPostSolveEvent": () => (/* reexport */ CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (/* reexport */ CollisionPreSolveEvent),
  "CollisionResolutionStrategy": () => (/* reexport */ CollisionResolutionStrategy),
  "CollisionStartEvent": () => (/* reexport */ CollisionStartEvent),
  "CollisionSystem": () => (/* reexport */ CollisionSystem),
  "CollisionType": () => (/* reexport */ CollisionType),
  "Color": () => (/* reexport */ Color),
  "ColorBlindFlags": () => (/* reexport */ ColorBlindFlags),
  "ColorBlindnessMode": () => (/* reexport */ ColorBlindnessMode),
  "ColorBlindnessPostProcessor": () => (/* reexport */ ColorBlindnessPostProcessor),
  "Component": () => (/* reexport */ Component),
  "CompositeCollider": () => (/* reexport */ CompositeCollider),
  "Configurable": () => (/* reexport */ Configurable),
  "ConsoleAppender": () => (/* reexport */ ConsoleAppender),
  "ContactConstraintPoint": () => (/* reexport */ ContactConstraintPoint),
  "ContactEndEvent": () => (/* reexport */ ContactEndEvent),
  "ContactStartEvent": () => (/* reexport */ ContactStartEvent),
  "CoordPlane": () => (/* reexport */ CoordPlane),
  "DeactivateEvent": () => (/* reexport */ DeactivateEvent),
  "Debug": () => (/* reexport */ Debug),
  "DebugGraphicsComponent": () => (/* reexport */ DebugGraphicsComponent),
  "DebugSystem": () => (/* reexport */ DebugSystem),
  "DebugText": () => (/* reexport */ DebugText),
  "DegreeOfFreedom": () => (/* reexport */ DegreeOfFreedom),
  "Delay": () => (/* reexport */ Delay),
  "Detector": () => (/* reexport */ Detector),
  "Die": () => (/* reexport */ Die),
  "Direction": () => (/* reexport */ Direction),
  "DisplayMode": () => (/* reexport */ DisplayMode),
  "DynamicTree": () => (/* reexport */ DynamicTree),
  "DynamicTreeCollisionProcessor": () => (/* reexport */ DynamicTreeCollisionProcessor),
  "EX_VERSION": () => (/* binding */ EX_VERSION),
  "EaseBy": () => (/* reexport */ EaseBy),
  "EaseTo": () => (/* reexport */ EaseTo),
  "EasingFunctions": () => (/* reexport */ EasingFunctions),
  "EdgeCollider": () => (/* reexport */ EdgeCollider),
  "ElasticToActorStrategy": () => (/* reexport */ ElasticToActorStrategy),
  "EmitterType": () => (/* reexport */ EmitterType),
  "Engine": () => (/* reexport */ Engine),
  "EnterTriggerEvent": () => (/* reexport */ EnterTriggerEvent),
  "EnterViewPortEvent": () => (/* reexport */ EnterViewPortEvent),
  "Entity": () => (/* reexport */ Entity),
  "EntityManager": () => (/* reexport */ EntityManager),
  "EventDispatcher": () => (/* reexport */ EventDispatcher),
  "EventTypes": () => (/* reexport */ EventTypes),
  "Events": () => (/* reexport */ Events_namespaceObject),
  "ExResponse": () => (/* reexport */ ExResponse),
  "ExcaliburGraphicsContext2DCanvas": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),
  "ExcaliburGraphicsContextWebGL": () => (/* reexport */ ExcaliburGraphicsContextWebGL),
  "ExcaliburWebGLContextAccessor": () => (/* reexport */ ExcaliburWebGLContextAccessor),
  "ExitTriggerEvent": () => (/* reexport */ ExitTriggerEvent),
  "ExitViewPortEvent": () => (/* reexport */ ExitViewPortEvent),
  "Fade": () => (/* reexport */ Fade),
  "Flags": () => (/* reexport */ Flags),
  "Follow": () => (/* reexport */ Follow),
  "Font": () => (/* reexport */ Font),
  "FontStyle": () => (/* reexport */ FontStyle),
  "FontUnit": () => (/* reexport */ FontUnit),
  "FpsSampler": () => (/* reexport */ FpsSampler),
  "FrameStats": () => (/* reexport */ FrameStats),
  "Future": () => (/* reexport */ Future),
  "GameEvent": () => (/* reexport */ GameEvent),
  "GameStartEvent": () => (/* reexport */ GameStartEvent),
  "GameStopEvent": () => (/* reexport */ GameStopEvent),
  "GamepadAxisEvent": () => (/* reexport */ GamepadAxisEvent),
  "GamepadButtonEvent": () => (/* reexport */ GamepadButtonEvent),
  "GamepadConnectEvent": () => (/* reexport */ GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (/* reexport */ GamepadDisconnectEvent),
  "Gif": () => (/* reexport */ Gif),
  "GlobalCoordinates": () => (/* reexport */ GlobalCoordinates),
  "Graphic": () => (/* reexport */ Graphic),
  "GraphicsComponent": () => (/* reexport */ GraphicsComponent),
  "GraphicsGroup": () => (/* reexport */ GraphicsGroup),
  "GraphicsLayer": () => (/* reexport */ GraphicsLayer),
  "GraphicsLayers": () => (/* reexport */ GraphicsLayers),
  "GraphicsSystem": () => (/* reexport */ GraphicsSystem),
  "HiddenEvent": () => (/* reexport */ HiddenEvent),
  "ImageFiltering": () => (/* reexport */ ImageFiltering),
  "ImageSource": () => (/* reexport */ ImageSource),
  "InitializeEvent": () => (/* reexport */ InitializeEvent),
  "Input": () => (/* reexport */ Input_Index_namespaceObject),
  "Integrator": () => (/* reexport */ Integrator),
  "IsometricEntityComponent": () => (/* reexport */ IsometricEntityComponent),
  "IsometricEntitySystem": () => (/* reexport */ IsometricEntitySystem),
  "IsometricMap": () => (/* reexport */ IsometricMap),
  "IsometricTile": () => (/* reexport */ IsometricTile),
  "KillEvent": () => (/* reexport */ KillEvent),
  "Label": () => (/* reexport */ Label),
  "LimitCameraBoundsStrategy": () => (/* reexport */ LimitCameraBoundsStrategy),
  "Line": () => (/* reexport */ Line),
  "LineSegment": () => (/* reexport */ LineSegment),
  "Loader": () => (/* reexport */ Loader),
  "LockCameraToActorAxisStrategy": () => (/* reexport */ LockCameraToActorAxisStrategy),
  "LockCameraToActorStrategy": () => (/* reexport */ LockCameraToActorStrategy),
  "LogLevel": () => (/* reexport */ LogLevel),
  "Logger": () => (/* reexport */ Logger),
  "Matrix": () => (/* reexport */ Matrix),
  "MatrixLocations": () => (/* reexport */ MatrixLocations),
  "MediaEvent": () => (/* reexport */ MediaEvent),
  "Meet": () => (/* reexport */ Meet),
  "MotionComponent": () => (/* reexport */ MotionComponent),
  "MotionSystem": () => (/* reexport */ MotionSystem),
  "MoveBy": () => (/* reexport */ MoveBy),
  "MoveTo": () => (/* reexport */ MoveTo),
  "NativeSoundEvent": () => (/* reexport */ NativeSoundEvent),
  "NativeSoundProcessedEvent": () => (/* reexport */ NativeSoundProcessedEvent),
  "Observable": () => (/* reexport */ Observable),
  "OffscreenSystem": () => (/* reexport */ OffscreenSystem),
  "Pair": () => (/* reexport */ Pair),
  "ParallaxComponent": () => (/* reexport */ ParallaxComponent),
  "ParallelActions": () => (/* reexport */ ParallelActions),
  "ParseGif": () => (/* reexport */ ParseGif),
  "Particle": () => (/* reexport */ Particle),
  "ParticleEmitter": () => (/* reexport */ ParticleEmitter),
  "Physics": () => (/* reexport */ Physics),
  "PhysicsStats": () => (/* reexport */ PhysicsStats),
  "PointerComponent": () => (/* reexport */ PointerComponent),
  "PointerSystem": () => (/* reexport */ PointerSystem),
  "Polygon": () => (/* reexport */ Polygon),
  "PolygonCollider": () => (/* reexport */ PolygonCollider),
  "Pool": () => (/* reexport */ Pool),
  "PostCollisionEvent": () => (/* reexport */ PostCollisionEvent),
  "PostDebugDrawEvent": () => (/* reexport */ PostDebugDrawEvent),
  "PostDrawEvent": () => (/* reexport */ PostDrawEvent),
  "PostFrameEvent": () => (/* reexport */ PostFrameEvent),
  "PostKillEvent": () => (/* reexport */ PostKillEvent),
  "PostUpdateEvent": () => (/* reexport */ PostUpdateEvent),
  "PreCollisionEvent": () => (/* reexport */ PreCollisionEvent),
  "PreDebugDrawEvent": () => (/* reexport */ PreDebugDrawEvent),
  "PreDrawEvent": () => (/* reexport */ PreDrawEvent),
  "PreFrameEvent": () => (/* reexport */ PreFrameEvent),
  "PreKillEvent": () => (/* reexport */ PreKillEvent),
  "PreUpdateEvent": () => (/* reexport */ PreUpdateEvent),
  "Projection": () => (/* reexport */ Projection),
  "QuadIndexBuffer": () => (/* reexport */ QuadIndexBuffer),
  "Query": () => (/* reexport */ Query),
  "QueryManager": () => (/* reexport */ QueryManager),
  "RadiusAroundActorStrategy": () => (/* reexport */ RadiusAroundActorStrategy),
  "Random": () => (/* reexport */ Random),
  "Raster": () => (/* reexport */ Raster),
  "Ray": () => (/* reexport */ Ray),
  "RealisticSolver": () => (/* reexport */ RealisticSolver),
  "Rectangle": () => (/* reexport */ Rectangle),
  "RemovedComponent": () => (/* reexport */ RemovedComponent),
  "RemovedEntity": () => (/* reexport */ RemovedEntity),
  "Repeat": () => (/* reexport */ Repeat),
  "RepeatForever": () => (/* reexport */ RepeatForever),
  "Resolution": () => (/* reexport */ Resolution),
  "Resource": () => (/* reexport */ Resource),
  "RotateBy": () => (/* reexport */ RotateBy),
  "RotateTo": () => (/* reexport */ RotateTo),
  "RotationType": () => (/* reexport */ RotationType),
  "ScaleBy": () => (/* reexport */ ScaleBy),
  "ScaleTo": () => (/* reexport */ ScaleTo),
  "Scene": () => (/* reexport */ Scene),
  "Screen": () => (/* reexport */ Screen),
  "ScreenAppender": () => (/* reexport */ ScreenAppender),
  "ScreenElement": () => (/* reexport */ ScreenElement),
  "ScreenShader": () => (/* reexport */ ScreenShader),
  "ScrollPreventionMode": () => (/* reexport */ ScrollPreventionMode),
  "Semaphore": () => (/* reexport */ Semaphore),
  "Shader": () => (/* reexport */ Shader),
  "Shape": () => (/* reexport */ Shape),
  "Side": () => (/* reexport */ Side),
  "Sound": () => (/* reexport */ Sound),
  "Sprite": () => (/* reexport */ Sprite),
  "SpriteFont": () => (/* reexport */ SpriteFont),
  "SpriteSheet": () => (/* reexport */ SpriteSheet),
  "StandardClock": () => (/* reexport */ StandardClock),
  "StateMachine": () => (/* reexport */ StateMachine),
  "StrategyContainer": () => (/* reexport */ StrategyContainer),
  "Stream": () => (/* reexport */ Stream),
  "System": () => (/* reexport */ System),
  "SystemManager": () => (/* reexport */ SystemManager),
  "SystemType": () => (/* reexport */ SystemType),
  "TagComponent": () => (/* reexport */ TagComponent),
  "TestClock": () => (/* reexport */ TestClock),
  "Text": () => (/* reexport */ Text),
  "TextAlign": () => (/* reexport */ TextAlign),
  "TextureLoader": () => (/* reexport */ TextureLoader),
  "Tile": () => (/* reexport */ Tile),
  "TileMap": () => (/* reexport */ TileMap),
  "Timer": () => (/* reexport */ Timer),
  "Toaster": () => (/* reexport */ Toaster),
  "Transform": () => (/* reexport */ Transform),
  "TransformComponent": () => (/* reexport */ TransformComponent),
  "TreeNode": () => (/* reexport */ TreeNode),
  "Trigger": () => (/* reexport */ Trigger),
  "TwoPI": () => (/* reexport */ TwoPI),
  "Util": () => (/* reexport */ Util_Index_namespaceObject),
  "Vector": () => (/* reexport */ Vector),
  "VectorView": () => (/* reexport */ VectorView),
  "VertexBuffer": () => (/* reexport */ VertexBuffer),
  "VertexLayout": () => (/* reexport */ VertexLayout),
  "VisibleEvent": () => (/* reexport */ VisibleEvent),
  "WebAudio": () => (/* reexport */ WebAudio),
  "WebAudioInstance": () => (/* reexport */ WebAudioInstance),
  "World": () => (/* reexport */ World),
  "canonicalizeAngle": () => (/* reexport */ canonicalizeAngle),
  "clamp": () => (/* reexport */ clamp),
  "createId": () => (/* reexport */ createId),
  "frac": () => (/* reexport */ frac),
  "hasGraphicsTick": () => (/* reexport */ hasGraphicsTick),
  "hasOnInitialize": () => (/* reexport */ hasOnInitialize),
  "hasOnPostUpdate": () => (/* reexport */ hasOnPostUpdate),
  "hasOnPreUpdate": () => (/* reexport */ hasOnPreUpdate),
  "hasPostDraw": () => (/* reexport */ hasPostDraw),
  "hasPreDraw": () => (/* reexport */ hasPreDraw),
  "has_initialize": () => (/* reexport */ has_initialize),
  "has_postupdate": () => (/* reexport */ has_postupdate),
  "has_preupdate": () => (/* reexport */ has_preupdate),
  "isAddedComponent": () => (/* reexport */ isAddedComponent),
  "isAddedSystemEntity": () => (/* reexport */ isAddedSystemEntity),
  "isRemoveSystemEntity": () => (/* reexport */ isRemoveSystemEntity),
  "isRemovedComponent": () => (/* reexport */ isRemovedComponent),
  "isScreenElement": () => (/* reexport */ isScreenElement),
  "maxMessages": () => (/* reexport */ maxMessages),
  "obsolete": () => (/* reexport */ obsolete),
  "pixelSnapEpsilon": () => (/* reexport */ pixelSnapEpsilon),
  "randomInRange": () => (/* reexport */ randomInRange),
  "randomIntInRange": () => (/* reexport */ randomIntInRange),
  "range": () => (/* reexport */ range),
  "resetObsoleteCounter": () => (/* reexport */ resetObsoleteCounter),
  "sign": () => (/* reexport */ sign),
  "toDegrees": () => (/* reexport */ toDegrees),
  "toRadians": () => (/* reexport */ toRadians),
  "vec": () => (/* reexport */ vec),
  "webgl": () => (/* reexport */ webgl_util_namespaceObject)
});

// NAMESPACE OBJECT: ./Events.ts
var Events_namespaceObject = {};
__webpack_require__.r(Events_namespaceObject);
__webpack_require__.d(Events_namespaceObject, {
  "ActivateEvent": () => (ActivateEvent),
  "CollisionEndEvent": () => (CollisionEndEvent),
  "CollisionPostSolveEvent": () => (CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (CollisionPreSolveEvent),
  "CollisionStartEvent": () => (CollisionStartEvent),
  "ContactEndEvent": () => (ContactEndEvent),
  "ContactStartEvent": () => (ContactStartEvent),
  "DeactivateEvent": () => (DeactivateEvent),
  "EnterTriggerEvent": () => (EnterTriggerEvent),
  "EnterViewPortEvent": () => (EnterViewPortEvent),
  "EventTypes": () => (EventTypes),
  "ExitTriggerEvent": () => (ExitTriggerEvent),
  "ExitViewPortEvent": () => (ExitViewPortEvent),
  "GameEvent": () => (GameEvent),
  "GameStartEvent": () => (GameStartEvent),
  "GameStopEvent": () => (GameStopEvent),
  "GamepadAxisEvent": () => (GamepadAxisEvent),
  "GamepadButtonEvent": () => (GamepadButtonEvent),
  "GamepadConnectEvent": () => (GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (GamepadDisconnectEvent),
  "HiddenEvent": () => (HiddenEvent),
  "InitializeEvent": () => (InitializeEvent),
  "KillEvent": () => (KillEvent),
  "PostCollisionEvent": () => (PostCollisionEvent),
  "PostDebugDrawEvent": () => (PostDebugDrawEvent),
  "PostDrawEvent": () => (PostDrawEvent),
  "PostFrameEvent": () => (PostFrameEvent),
  "PostKillEvent": () => (PostKillEvent),
  "PostUpdateEvent": () => (PostUpdateEvent),
  "PreCollisionEvent": () => (PreCollisionEvent),
  "PreDebugDrawEvent": () => (PreDebugDrawEvent),
  "PreDrawEvent": () => (PreDrawEvent),
  "PreFrameEvent": () => (PreFrameEvent),
  "PreKillEvent": () => (PreKillEvent),
  "PreUpdateEvent": () => (PreUpdateEvent),
  "VisibleEvent": () => (VisibleEvent)
});

// NAMESPACE OBJECT: ./Graphics/Context/webgl-util.ts
var webgl_util_namespaceObject = {};
__webpack_require__.r(webgl_util_namespaceObject);
__webpack_require__.d(webgl_util_namespaceObject, {
  "getAttributeComponentSize": () => (getAttributeComponentSize),
  "getAttributePointerType": () => (getAttributePointerType),
  "getGlTypeSizeBytes": () => (getGlTypeSizeBytes)
});

// NAMESPACE OBJECT: ./Util/DrawUtil.ts
var DrawUtil_namespaceObject = {};
__webpack_require__.r(DrawUtil_namespaceObject);
__webpack_require__.d(DrawUtil_namespaceObject, {
  "circle": () => (circle),
  "line": () => (line),
  "point": () => (point),
  "roundRect": () => (roundRect),
  "vector": () => (vector)
});

// NAMESPACE OBJECT: ./Input/Index.ts
var Input_Index_namespaceObject = {};
__webpack_require__.r(Input_Index_namespaceObject);
__webpack_require__.d(Input_Index_namespaceObject, {
  "Axes": () => (Axes),
  "Buttons": () => (Buttons),
  "Gamepad": () => (Gamepad),
  "Gamepads": () => (Gamepads),
  "KeyEvent": () => (KeyEvent),
  "Keyboard": () => (Keyboard),
  "Keys": () => (Keys),
  "NativePointerButton": () => (NativePointerButton),
  "PointerButton": () => (PointerButton),
  "PointerComponent": () => (PointerComponent),
  "PointerEvent": () => (PointerEvent),
  "PointerEventReceiver": () => (PointerEventReceiver),
  "PointerScope": () => (PointerScope),
  "PointerSystem": () => (PointerSystem),
  "PointerType": () => (PointerType),
  "WheelDeltaMode": () => (WheelDeltaMode),
  "WheelEvent": () => (WheelEvent)
});

// NAMESPACE OBJECT: ./Util/Index.ts
var Util_Index_namespaceObject = {};
__webpack_require__.r(Util_Index_namespaceObject);
__webpack_require__.d(Util_Index_namespaceObject, {
  "ConsoleAppender": () => (ConsoleAppender),
  "DrawUtil": () => (DrawUtil_namespaceObject),
  "EasingFunctions": () => (EasingFunctions),
  "LogLevel": () => (LogLevel),
  "Logger": () => (Logger),
  "Observable": () => (Observable),
  "ScreenAppender": () => (ScreenAppender),
  "addItemToArray": () => (addItemToArray),
  "contains": () => (contains),
  "delay": () => (delay),
  "fail": () => (fail),
  "getPosition": () => (getPosition),
  "removeItemFromArray": () => (removeItemFromArray)
});

// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js
var sort = __webpack_require__(4662);
// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js
var keys = __webpack_require__(8343);
;// CONCATENATED MODULE: ./Polyfill.ts


/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}

;// CONCATENATED MODULE: ./Flags.ts
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Force excalibur to load the Canvas 2D graphics context fallback
     *
     * @warning not all features of excalibur are supported in the Canvas 2D fallback
     */
    static useCanvasGraphicsContext() {
        Flags.enable('use-canvas-context');
    }
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};

;// CONCATENATED MODULE: ./Id.ts
/**
 * Create a branded ID type from a number
 */
function createId(type, value) {
    return { type, value };
}
;

;// CONCATENATED MODULE: ./Math/Random.ts
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}

;// CONCATENATED MODULE: ./Math/util.ts

/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Returns the fractional part of a number
 * @param x
 */
function frac(x) {
    if (x >= 0) {
        return x - Math.floor(x);
    }
    else {
        return x - Math.ceil(x);
    }
}
/**
 * Returns the sign of a number, if 0 returns 0
 */
function sign(val) {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
}
;
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}

;// CONCATENATED MODULE: ./Math/vector.ts

/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    static min(vec1, vec2) {
        return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));
    }
    static max(vec1, vec2) {
        return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return deltaX * deltaX + deltaY * deltaY;
    }
    /**
     * Clamps the current vector's magnitude mutating it
     * @param magnitude
     */
    clampMagnitude(magnitude) {
        const size = this.size;
        const newSize = clamp(size, 0, magnitude);
        this.size = newSize;
        return this;
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale, dest) {
        const result = dest || new Vector(0, 0);
        if (sizeOrScale instanceof Vector) {
            result.x = this.x * sizeOrScale.x;
            result.y = this.y * sizeOrScale.y;
        }
        else {
            result.x = this.x * sizeOrScale;
            result.y = this.y * sizeOrScale;
        }
        return result;
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     * @param dest Optionally copy the result into a provided vector
     */
    add(v, dest) {
        if (dest) {
            dest.x = this.x + v.x;
            dest.y = this.y + v.y;
            return dest;
        }
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone(dest) {
        const v = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);
        v.x = this.x;
        v.y = this.y;
        return v;
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}

;// CONCATENATED MODULE: ./Util/Log.ts
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}

;// CONCATENATED MODULE: ./Color.ts
/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
}
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}

;// CONCATENATED MODULE: ./Collision/Side.ts

/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction (via dot product)
     */
    function fromDirection(direction) {
        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
        let max = -Number.MAX_VALUE;
        let maxIndex = -1;
        for (let i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));

;// CONCATENATED MODULE: ./Collision/BoundingBox.ts



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Returns a new instance of [[BoundingBox]] that is a copy of the current instance
     */
    clone() {
        return new BoundingBox(this.left, this.top, this.right, this.bottom);
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return Side.Right;
                }
                return Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return Side.Bottom;
                }
                return Side.Top;
            }
        }
        return Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Scale a bounding box by a scale factor, optionally provide a point
     * @param scale
     * @param point
     */
    scale(scale, point = Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    /**
     * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box
     * @param matrix
     */
    transform(matrix) {
        // inlined these calculations to not use vectors would speed it up slightly
        // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);
        // const xa = matFirstColumn.scale(this.left);
        const xa1 = matrix.data[0] * this.left;
        const xa2 = matrix.data[1] * this.left;
        // const xb = matFirstColumn.scale(this.right);
        const xb1 = matrix.data[0] * this.right;
        const xb2 = matrix.data[1] * this.right;
        // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);
        // const ya = matSecondColumn.scale(this.top);
        const ya1 = matrix.data[2] * this.top;
        const ya2 = matrix.data[3] * this.top;
        // const yb = matSecondColumn.scale(this.bottom);
        const yb1 = matrix.data[2] * this.bottom;
        const yb2 = matrix.data[3] * this.bottom;
        const matrixPos = matrix.getPosition();
        // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);
        // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);
        const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;
        const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;
        const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;
        const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;
        return new BoundingBox({
            left,
            top,
            right,
            bottom //: bottomRight.y
        });
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new Vector(this.left, this.top));
        results.push(new Vector(this.right, this.top));
        results.push(new Vector(this.right, this.bottom));
        results.push(new Vector(this.left, this.bottom));
        return results;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof Vector) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new Vector(this.width, this.height);
    }
    /**
     * Returns true if the bounding boxes overlap.
     * @param other
     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
     * This epsilon is useful in stable collision simulations.
     */
    overlaps(other, epsilon) {
        const e = epsilon || 0;
        if (other.hasZeroDimensions()) {
            return this.contains(other);
        }
        if (this.hasZeroDimensions()) {
            return other.contains(this);
        }
        const totalBoundingBox = this.combine(other);
        return totalBoundingBox.width + e < other.width + this.width &&
            totalBoundingBox.height + e < other.height + this.height;
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}

;// CONCATENATED MODULE: ./Util/Future.ts
/**
 * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time
 */
class Future {
    constructor() {
        this._isCompleted = false;
        this.promise = new Promise((resolve, reject) => {
            this._resolver = resolve;
            this._rejecter = reject;
        });
    }
    get isCompleted() {
        return this._isCompleted;
    }
    resolve(value) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._resolver(value);
    }
    reject(error) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._rejecter(error);
    }
}

;// CONCATENATED MODULE: ./Util/Util.ts


/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new Vector(oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Create a promise that resolves after a certain number of milliseconds
 *
 * It is strongly recommended you pass the excalibur clock so delays are bound to the
 * excalibur clock which would be unaffected by stop/pause.
 * @param milliseconds
 * @param clock
 */
function delay(milliseconds, clock) {
    var _a;
    const future = new Future();
    const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;
    schedule(() => {
        future.resolve();
    }, milliseconds);
    return future.promise;
}

;// CONCATENATED MODULE: ./Math/matrix.ts



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- | -------- |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleX = 1;
        this._scaleSignX = 1;
        this._scaleY = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
        const mat = dest || new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static fromFloat32Array(data) {
        const matrix = new Matrix();
        matrix.data = data;
        return matrix;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {Matrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[4] = -Math.sin(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[5] = Math.cos(angleRadians);
        return mat;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof Vector) {
            const result = dest || new Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];
            const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new Matrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            const a31 = this.data[2];
            const a41 = this.data[3];
            const a12 = this.data[4];
            const a22 = this.data[5];
            const a32 = this.data[6];
            const a42 = this.data[7];
            const a13 = this.data[8];
            const a23 = this.data[9];
            const a33 = this.data[10];
            const a43 = this.data[11];
            const a14 = this.data[12];
            const a24 = this.data[13];
            const a34 = this.data[14];
            const a44 = this.data[15];
            const b11 = other.data[0];
            const b21 = other.data[1];
            const b31 = other.data[2];
            const b41 = other.data[3];
            const b12 = other.data[4];
            const b22 = other.data[5];
            const b32 = other.data[6];
            const b42 = other.data[7];
            const b13 = other.data[8];
            const b23 = other.data[9];
            const b33 = other.data[10];
            const b43 = other.data[11];
            const b14 = other.data[12];
            const b24 = other.data[13];
            const b34 = other.data[14];
            const b44 = other.data[15];
            result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            const s = this.getScale();
            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);
            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);
            return result;
        }
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[4]).size;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[5]).size;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (this._scaleX === val) {
            return;
        }
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
        this._scaleX = val;
    }
    setScaleY(val) {
        if (this._scaleY === val) {
            return;
        }
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
        this._scaleY = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    getAffineInverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = target || Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}

;// CONCATENATED MODULE: ./Math/affine-matrix.ts



class AffineMatrix {
    constructor() {
        /**
         * |         |         |          |
         * | ------- | ------- | -------- |
         * | data[0] | data[2] | data[4]  |
         * | data[1] | data[3] | data[5]  |
         * |   0     |    0    |    1     |
         */
        this.data = new Float64Array(6);
        this._scale = new Float64Array([1, 1]);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static identity() {
        const mat = new AffineMatrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = AffineMatrix.identity();
        mat.data[4] = x;
        mat.data[5] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = AffineMatrix.identity();
        mat.data[0] = sx;
        mat.data[3] = sy;
        mat._scale[0] = sx;
        mat._scale[1] = sy;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = AffineMatrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[2] = -Math.sin(angleRadians);
        mat.data[3] = Math.cos(angleRadians);
        return mat;
    }
    setPosition(x, y) {
        this.data[4] = x;
        this.data[5] = y;
    }
    getPosition() {
        return vec(this.data[4], this.data[5]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a12 - sine * a11;
        this.data[3] = cosine * a22 - sine * a21;
        return this;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        // const a31 = 0;
        const a12 = this.data[2];
        const a22 = this.data[3];
        // const a32 = 0;
        const a13 = this.data[4];
        const a23 = this.data[5];
        // const a33 = 1;
        // Doesn't change z
        this.data[4] = a11 * x + a12 * y + a13;
        this.data[5] = a21 * x + a22 * y + a23;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a12 * y;
        this.data[3] = a22 * y;
        this._scale[0] = x;
        this._scale[1] = y;
        return this;
    }
    determinant() {
        return this.data[0] * this.data[3] - this.data[1] * this.data[2];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    inverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.determinant();
        const inverseDet = 1 / det; // TODO zero check
        const a = this.data[0];
        const b = this.data[2];
        const c = this.data[1];
        const d = this.data[3];
        const m = target || AffineMatrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[2] = -b * inverseDet;
        m.data[3] = a * inverseDet;
        const tx = this.data[4];
        const ty = this.data[5];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[4] = -(tx * m.data[0] + ty * m.data[2]);
        m.data[5] = -(tx * m.data[1] + ty * m.data[3]);
        return m;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof Vector) {
            const result = dest || new Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];
            const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new AffineMatrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            //  const a31 = 0;
            const a12 = this.data[2];
            const a22 = this.data[3];
            //  const a32 = 0;
            const a13 = this.data[4];
            const a23 = this.data[5];
            //  const a33 = 1;
            const b11 = other.data[0];
            const b21 = other.data[1];
            //  const b31 = 0;
            const b12 = other.data[2];
            const b22 = other.data[3];
            //  const b32 = 0;
            const b13 = other.data[4];
            const b23 = other.data[5];
            //  const b33 = 1;
            result.data[0] = a11 * b11 + a12 * b21; // + a13 * b31; // zero
            result.data[1] = a21 * b11 + a22 * b21; // + a23 * b31; // zero
            result.data[2] = a11 * b12 + a12 * b22; // + a13 * b32; // zero
            result.data[3] = a21 * b12 + a22 * b22; // + a23 * b32; // zero
            result.data[4] = a11 * b13 + a12 * b23 + a13; // * b33; // one
            result.data[5] = a21 * b13 + a22 * b23 + a23; // * b33; // one
            const s = this.getScale();
            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);
            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);
            return result;
        }
    }
    to4x4() {
        const mat = new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = this.data[2];
        mat.data[5] = this.data[3];
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = this.data[4];
        mat.data[13] = this.data[5];
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[2] = -sine * currentScale.x;
        this.data[3] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[2]).distance();
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[3]).distance();
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (val === this._scale[0]) {
            return;
        }
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[2] = xscale.y * val;
        this._scale[0] = val;
    }
    setScaleY(val) {
        if (val === this._scale[1]) {
            return;
        }
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[3] = yscale.y * val;
        this._scale[1] = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 1 &&
            this.data[4] === 0 &&
            this.data[5] === 0);
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {AffineMatrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
        const mat = dest || new AffineMatrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        return mat;
    }
    toString() {
        return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts

class TransformStack {
    constructor() {
        this._transforms = [];
        this._currentTransform = AffineMatrix.identity();
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone();
    }
    restore() {
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts

class StateStack {
    constructor() {
        this._states = [];
        this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
        return {
            opacity: 1,
            z: 0,
            tint: Color.White
        };
    }
    _cloneState() {
        return {
            opacity: this._currentState.opacity,
            z: this._currentState.z,
            tint: this._currentState.tint.clone()
        };
    }
    save() {
        this._states.push(this._currentState);
        this._currentState = this._cloneState();
    }
    restore() {
        this._currentState = this._states.pop();
    }
    get current() {
        return this._currentState;
    }
    set current(val) {
        this._currentState = val;
    }
}

;// CONCATENATED MODULE: ./Events.ts
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
class ContactStartEvent {
    constructor(target, other, contact) {
        this.target = target;
        this.other = other;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(target, other) {
        this.target = target;
        this.other = other;
    }
}
class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
        super();
        this.other = other;
        this.contact = contact;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene activation
     */
    constructor(context, target) {
        super();
        this.context = context;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene deactivation
     */
    constructor(context, target) {
        super();
        this.context = context;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}

;// CONCATENATED MODULE: ./EventDispatcher.ts

class EventDispatcher {
    constructor() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._deferedHandlerRemovals = [];
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    _processDeferredHandlerRemovals() {
        for (const eventHandler of this._deferedHandlerRemovals) {
            this._removeHandler(eventHandler.name, eventHandler.handler);
        }
        this._deferedHandlerRemovals.length = 0;
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        this._processDeferredHandlerRemovals();
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        if (!event) {
            event = new GameEvent();
        }
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i](event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        this._processDeferredHandlerRemovals();
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
        this._deferedHandlerRemovals.push({ name: eventName, handler });
    }
    _removeHandler(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                if (index > -1) {
                    this._handlers[eventName].splice(index, 1);
                }
            }
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this._processDeferredHandlerRemovals();
        const metaHandler = (event) => {
            const ev = event || new GameEvent();
            this.off(eventName, metaHandler);
            handler(ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Resource.ts


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = Logger.getInstance();
        this.events = new EventDispatcher();
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}

;// CONCATENATED MODULE: ./Util/Watch.ts
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}

;// CONCATENATED MODULE: ./Graphics/Graphic.ts




/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].
 * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the
 * [[Graphic]] abstract class.
 *
 * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]
 */
class Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this.id = Graphic._ID++;
        this.transform = AffineMatrix.identity();
        this.tint = null;
        this._transformStale = true;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        this._flipHorizontal = false;
        this._flipVertical = false;
        this._rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        this._scale = Vector.One;
        this._origin = null;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
        }
    }
    isStale() {
        return this._transformStale;
    }
    /**
     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
     */
    get flipHorizontal() {
        return this._flipHorizontal;
    }
    set flipHorizontal(value) {
        this._flipHorizontal = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
     */
    get flipVertical() {
        return this._flipVertical;
    }
    set flipVertical(value) {
        this._flipVertical = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the rotation of the graphic
     */
    get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        this._rotation = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the scale of the graphic, this affects the width and
     */
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = watch(value, () => {
            this._transformStale = true;
        });
        this._transformStale = true;
    }
    /**
     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
     */
    get origin() {
        return this._origin;
    }
    set origin(value) {
        this._origin = watch(value, () => {
            this._transformStale = true;
        });
        this._transformStale = true;
    }
    cloneGraphicOptions() {
        return {
            origin: this.origin ? this.origin.clone() : null,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : null
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
        this._transformStale = true;
    }
    set height(value) {
        this._height = value;
        this._transformStale = true;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        if (this._transformStale) {
            this.transform.reset();
            this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
            this._rotate(this.transform);
            this._flip(this.transform);
            this._transformStale = false;
        }
        ex.multiply(this.transform);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
        if (this.tint) {
            ex.tint = this.tint;
        }
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any additional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;

;// CONCATENATED MODULE: ./Graphics/Sprite.ts


class Sprite extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._logger = Logger.getInstance();
        this._dirty = true;
        this._logNotLoadedWarning = false;
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    static from(image) {
        return new Sprite({
            image: image
        });
    }
    get width() {
        return Math.abs(this.destSize.width * this.scale.x);
    }
    get height() {
        return Math.abs(this.destSize.height * this.scale.y);
    }
    set width(newWidth) {
        newWidth /= Math.abs(this.scale.x);
        this.destSize.width = newWidth;
        super.width = Math.ceil(this.destSize.width);
    }
    set height(newHeight) {
        newHeight /= Math.abs(this.scale.y);
        this.destSize.height = newHeight;
        super.height = Math.ceil(this.destSize.height);
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width) * this.scale.x;
        this.height = Math.ceil(this.destSize.height) * this.scale.y;
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded() && this._dirty) {
            this._dirty = false;
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
        else {
            if (!this._logNotLoadedWarning) {
                this._logger.warn(`ImageSource ${this.image.path}` +
                    ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\n\n` +
                    `Read https://excaliburjs.com/docs/imagesource for more information.`);
            }
            this._logNotLoadedWarning = true;
        }
    }
    clone() {
        return new Sprite({
            image: this.image,
            sourceView: { ...this.sourceView },
            destSize: { ...this.destSize },
            ...this.cloneGraphicOptions()
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Filtering.ts
/**
 * Describes the different image filtering modes
 */
var ImageFiltering;
(function (ImageFiltering) {
    /**
     * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.
     *
     * Useful for Pixel art aesthetics.
     */
    ImageFiltering["Pixel"] = "Pixel";
    /**
     * Blended is useful when you have high resolution artwork and would like it blended and smoothed
     */
    ImageFiltering["Blended"] = "Blended";
})(ImageFiltering || (ImageFiltering = {}));

;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts


/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    static register(context) {
        TextureLoader._GL = context;
        TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    static get(image) {
        return TextureLoader._TEXTURE_MAP.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    static has(image) {
        return TextureLoader._TEXTURE_MAP.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    static load(image, filtering, forceUpdate = false) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        // If reuse the texture if it's from the same source
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            }
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        TextureLoader.checkImageSizeSupportedAndLog(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // NEAREST for pixel art, LINEAR for hi-res
        const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        TextureLoader._TEXTURE_MAP.set(image, tex);
        return tex;
    }
    static delete(image) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
            gl.deleteTexture(tex);
        }
    }
    /**
     * Takes an image and returns if it meets size criteria for hardware
     * @param image
     * @returns if the image will be supported at runtime
     */
    static checkImageSizeSupportedAndLog(image) {
        var _a;
        const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : 'internal canvas bitmap';
        if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {
            TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of ` +
                `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `
                + `for excalibur to render properly.\n\nImages will likely render as black rectangles.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
            return false;
        }
        else if (image.width > 4096 || image.height > 4096) {
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits
            TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, ` +
                `it is recommended you resize images to a maximum (4096x4096).\n\n` +
                `Images will likely render as black rectangles on some mobile platforms.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
        }
        return true;
    }
}
TextureLoader._LOGGER = Logger.getInstance();
/**
 * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]
 */
TextureLoader.filtering = ImageFiltering.Blended;
TextureLoader._TEXTURE_MAP = new Map();
TextureLoader._MAX_TEXTURE_SIZE = 0;

;// CONCATENATED MODULE: ./Graphics/ImageSource.ts





class ImageSource {
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute
     * @param bustCache {boolean} Should excalibur add a cache busting querystring?
     * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]
     */
    constructor(path, bustCache = false, filtering) {
        this.path = path;
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image element
         */
        this.data = new Image();
        this._readyFuture = new Future();
        /**
         * Promise the resolves when the image is loaded and ready for use, does not initiate loading
         */
        this.ready = this._readyFuture.promise;
        this._resource = new Resource(path, 'blob', bustCache);
        this._filtering = filtering;
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
    }
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        if (!this._src) {
            // this boosts speed of access
            this._src = this.data.src;
        }
        return !!this._src;
    }
    get image() {
        return this.data;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    async load() {
        if (this.isLoaded()) {
            return this.data;
        }
        try {
            // Load base64 or blob if needed
            let url;
            if (!this.path.includes('data:image/')) {
                const blob = await this._resource.load();
                url = URL.createObjectURL(blob);
            }
            else {
                url = this.path;
            }
            // Decode the image
            const image = new Image();
            // Use Image.onload over Image.decode()
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7
            // Otherwise chrome will throw still Image.decode() failures for large textures
            const loadedFuture = new Future();
            image.onload = () => loadedFuture.resolve();
            image.src = url;
            image.setAttribute('data-original-src', this.path);
            await loadedFuture.promise;
            // Set results
            this.data = image;
        }
        catch (error) {
            throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
        }
        TextureLoader.load(this.data, this._filtering);
        // todo emit complete
        this._readyFuture.resolve(this.data);
        return this.data;
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts


/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
        this._logger = Logger.getInstance();
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x, y) {
        if (x >= this.columns || x < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);
            return null;
        }
        if (y >= this.rows || y < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);
            return null;
        }
        const spriteIndex = x + y * this.columns;
        return this.sprites[spriteIndex];
    }
    /**
     * Create a sprite sheet from a sparse set of [[SourceView]] rectangles
     * @param options
     */
    static fromImageSourceWithSourceViews(options) {
        const sprites = options.sourceViews.map(sourceView => {
            return new Sprite({
                image: options.image,
                sourceView
            });
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = { x: 0, y: 0, ...originOffset };
        const marginDefaults = { x: 0, y: 0, ...margin };
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts




class SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this._logger = Logger.getInstance();
        this._alreadyWarnedAlphabet = false;
        this._alreadyWarnedSpriteSheet = false;
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
    }
    _getCharacterSprites(text) {
        const results = [];
        // handle case insensitive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                if (!this._alreadyWarnedAlphabet) {
                    this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
                    this._alreadyWarnedAlphabet = true;
                }
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                if (!this._alreadyWarnedSpriteSheet) {
                    this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
                    this._alreadyWarnedSpriteSheet = true;
                }
            }
        }
        return results;
    }
    measureText(text) {
        const lines = text.split('\n');
        const maxWidthLine = lines.reduce((a, b) => {
            return a.length > b.length ? a : b;
        });
        const sprites = this._getCharacterSprites(maxWidthLine);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);
    }
    _drawImage(ex, x, y) {
        let xCursor = 0;
        let yCursor = 0;
        let height = 0;
        const lines = this._text.split('\n');
        for (const line of lines) {
            for (const sprite of this._getCharacterSprites(line)) {
                // draw it in the right spot and increase the cursor by sprite width
                sprite.draw(ex, x + xCursor, y + yCursor);
                xCursor += sprite.width + this.spacing;
                height = Math.max(height, sprite.height);
            }
            xCursor = 0;
            yCursor += height;
        }
    }
    render(ex, text, _color, x, y) {
        // SpriteFont doesn't support _color, yet...
        this._text = text;
        const bounds = this.measureText(text);
        this.width = bounds.width;
        this.height = bounds.height;
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this.draw(ex, x, y);
            ex.restore();
        }
        this.draw(ex, x, y);
    }
    clone() {
        return new SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png
/* harmony default export */ const debug_font = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=");
;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts


/**
 * Internal debugtext helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = debug_font;
        this.size = 16;
        this.load();
    }
    load() {
        this._imageSource = new ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 3,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+ ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, null, pos.x, pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/render-source.ts
class RenderSource {
    constructor(_gl, _texture) {
        this._gl = _gl;
        this._texture = _texture;
    }
    use() {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
    }
    disable() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/render-target.ts

class RenderTarget {
    constructor(options) {
        this.width = options.width;
        this.height = options.height;
        this._gl = options.gl;
        this._setupFramebuffer();
    }
    setResolution(width, height) {
        const gl = this._gl;
        this.width = width;
        this.height = height;
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    get frameBuffer() {
        return this._frameBuffer;
    }
    get frameTexture() {
        return this._frameTexture;
    }
    _setupFramebuffer() {
        // Allocates frame buffer
        const gl = this._gl;
        this._frameTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // set the filtering so we don't need mips
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // attach the texture as the first color attachment
        const attachmentPoint = gl.COLOR_ATTACHMENT0;
        // After this bind all draw calls will draw to this framebuffer texture
        this._frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);
        // Reset after initialized
        this.disable();
    }
    toRenderSource() {
        const source = new RenderSource(this._gl, this._frameTexture);
        return source;
    }
    /**
     * When called, all drawing gets redirected to this render target
     */
    use() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        // very important to set the viewport to the size of the framebuffer texture
        gl.viewport(0, 0, this.width, this.height);
    }
    /**
     * When called, all drawing is sent back to the canvas
     */
    disable() {
        const gl = this._gl;
        // passing null switches rendering back to the canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/webgl-adapter.ts
/**
 * Must be accessed after Engine construction time to ensure the context has been created
 */
class ExcaliburWebGLContextAccessor {
    static clear() {
        ExcaliburWebGLContextAccessor._GL = null;
    }
    static register(gl) {
        ExcaliburWebGLContextAccessor._GL = gl;
    }
    // current webgl context
    static get gl() {
        if (!ExcaliburWebGLContextAccessor._GL) {
            throw Error('Attempted gl access before init');
        }
        return ExcaliburWebGLContextAccessor._GL;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-vertex.glsl
/* harmony default export */ const line_vertex = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\n\r\nout lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-fragment.glsl
/* harmony default export */ const line_fragment = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Color\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  fragColor = v_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts
/**
 * Return the size of the GlType in bytes
 * @param gl
 * @param type
 */
function getGlTypeSizeBytes(gl, type) {
    switch (type) {
        case gl.FLOAT:
            return 4;
        case gl.SHORT:
            return 2;
        case gl.UNSIGNED_SHORT:
            return 2;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        default:
            return 1;
    }
}
/**
 * Based on the type return the number of attribute components
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 * @param gl
 * @param type
 */
function getAttributeComponentSize(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
            return 1;
        case gl.FLOAT_VEC2:
            return 2;
        case gl.FLOAT_VEC3:
            return 3;
        case gl.FLOAT_VEC4:
            return 4;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        case gl.UNSIGNED_SHORT:
        case gl.SHORT:
            return 1;
        default:
            return 1;
    }
}
/**
 * Based on the attribute return the corresponding supported attrib pointer type
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 *
 * @param gl
 * @param type
 */
function getAttributePointerType(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
        case gl.FLOAT_VEC2:
        case gl.FLOAT_VEC3:
        case gl.FLOAT_VEC4:
            return gl.FLOAT;
        case gl.BYTE:
            return gl.BYTE;
        case gl.UNSIGNED_BYTE:
            return gl.UNSIGNED_BYTE;
        case gl.SHORT:
            return gl.SHORT;
        case gl.UNSIGNED_SHORT:
            return gl.UNSIGNED_SHORT;
        default:
            return gl.FLOAT;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shader.ts


class Shader {
    /**
     * Create a shader program in excalibur
     * @param options specify shader vertex and fragment source
     */
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this.uniforms = {};
        this.attributes = {};
        this._compiled = false;
        const { vertexSource, fragmentSource } = options;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
    }
    get compiled() {
        return this._compiled;
    }
    /**
     * Binds the shader program
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        Shader._ACTIVE_SHADER_INSTANCE = this;
    }
    isCurrentlyBound() {
        return Shader._ACTIVE_SHADER_INSTANCE === this;
    }
    /**
     * Compile the current shader against a webgl context
     */
    compile() {
        const gl = this._gl;
        const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);
        this.program = this._createProgram(gl, vertexShader, fragmentShader);
        const attributes = this.getAttributes();
        for (const attribute of attributes) {
            this.attributes[attribute.name] = attribute;
        }
        const uniforms = this.getUniforms();
        for (const uniform of uniforms) {
            this.uniforms[uniform.name] = uniform;
        }
        this._compiled = true;
        return this.program;
    }
    getUniforms() {
        const gl = this._gl;
        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        const uniforms = [];
        for (let i = 0; i < uniformCount; i++) {
            const uniform = gl.getActiveUniform(this.program, i);
            const uniformLocation = gl.getUniformLocation(this.program, uniform.name);
            uniforms.push({
                name: uniform.name,
                glType: uniform.type,
                location: uniformLocation
            });
        }
        return uniforms;
    }
    getAttributes() {
        const gl = this._gl;
        const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
        const attributes = [];
        for (let i = 0; i < attributeCount; i++) {
            const attribute = gl.getActiveAttrib(this.program, i);
            const attributeLocation = gl.getAttribLocation(this.program, attribute.name);
            attributes.push({
                name: attribute.name,
                glType: getAttributePointerType(gl, attribute.type),
                size: getAttributeComponentSize(gl, attribute.type),
                location: attributeLocation,
                normalized: false
            });
        }
        return attributes;
    }
    /**
     * Set a texture in a gpu texture slot
     * @param slotNumber
     * @param texture
     */
    setTexture(slotNumber, texture) {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0 + slotNumber);
        gl.bindTexture(gl.TEXTURE_2D, texture);
    }
    /**
     * Set an integer uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformInt(name, value) {
        this.setUniform('uniform1i', name, ~~value);
    }
    /**
     * Set an integer array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformIntArray(name, value) {
        this.setUniform('uniform1iv', name, value);
    }
    /**
     * Set a boolean uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformBoolean(name, value) {
        this.setUniform('uniform1i', name, value ? 1 : 0);
    }
    /**
     * Set a float uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloat(name, value) {
        this.setUniform('uniform1f', name, value);
    }
    /**
     * Set a float array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatArray(name, value) {
        this.setUniform('uniform1fv', name, value);
    }
    /**
     * Set a [[Vector]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatVector(name, value) {
        this.setUniform('uniform2f', name, value.x, value.y);
    }
    /**
     * Set an [[Matrix]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformMatrix(name, value) {
        this.setUniform('uniformMatrix4fv', name, false, value.data);
    }
    /**
     * Set any available uniform type in webgl
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     */
    setUniform(uniformType, name, ...value) {
        if (!this._compiled) {
            throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);
        }
        if (!this.isCurrentlyBound()) {
            throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +
                ' must call `shader.use()` before setting uniforms');
        }
        const gl = this._gl;
        const location = gl.getUniformLocation(this.program, name);
        if (location) {
            const args = [location, ...value];
            this._gl[uniformType].apply(this._gl, args);
        }
        else {
            throw Error(`Uniform ${uniformType}:${name} doesn\'t exist or is not used in the shader source code,` +
                ' unused uniforms are optimized away by most browsers');
        }
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            const errorInfo = gl.getShaderInfoLog(shader);
            throw Error(`Could not compile ${typeName} shader:\n\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);
        }
        return shader;
    }
    _processSourceForError(source, errorInfo) {
        const lines = source.split('\n');
        const errorLineStart = errorInfo.search(/\d:\d/);
        const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);
        const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));
        for (let i = 0; i < lines.length; i++) {
            lines[i] = `${i + 1}: ${lines[i]}${error2 === (i + 1) ? ' <----- ERROR!' : ''}`;
        }
        return '\n\nSource:\n' + lines.join('\n');
    }
}
Shader._ACTIVE_SHADER_INSTANCE = null;

;// CONCATENATED MODULE: ./Graphics/Context/vertex-buffer.ts

/**
 * Helper around vertex buffer to simplify creating and uploading geometry
 *
 * Under the hood uses Float32Array
 */
class VertexBuffer {
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        /**
         * If the vertices never change switching 'static' can be more efficient on the gpu
         *
         * Default is 'dynamic'
         */
        this.type = 'dynamic';
        const { size, type, data } = options;
        this.buffer = this._gl.createBuffer();
        if (!data && !size) {
            throw Error('Must either provide data or a size to the VertexBuffer');
        }
        if (!data) {
            this.bufferData = new Float32Array(size);
        }
        else {
            this.bufferData = data;
        }
        this.type = type !== null && type !== void 0 ? type : this.type;
        // Allocate buffer
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
    }
    /**
     * Bind this vertex buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    }
    /**
     * Upload vertex buffer geometry to the GPU
     */
    upload(count) {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        if (count) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);
        }
        else {
            // TODO always use bufferSubData? need to perf test it
            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/vertex-layout.ts



/**
 * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing
 * the memory layout for your vertices inside a particular buffer
 *
 * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.
 *
 * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you
 */
class VertexLayout {
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this._logger = Logger.getInstance();
        this._layout = [];
        this._attributes = [];
        this._vertexTotalSizeBytes = 0;
        const { shader, vertexBuffer, attributes } = options;
        this._vertexBuffer = vertexBuffer;
        this._attributes = attributes;
        this._shader = shader;
        this.initialize();
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get attributes() {
        return this._attributes;
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        return this._vertexTotalSizeBytes;
    }
    /**
     * Layouts need shader locations and must be bound to a shader
     */
    initialize() {
        if (!this._shader.compiled) {
            throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');
        }
        this._layout.length = 0;
        const shaderAttributes = this._shader.attributes;
        for (const attribute of this._attributes) {
            const attrib = shaderAttributes[attribute[0]];
            if (!attrib) {
                throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}` +
                    ` not found in the shader source code:\n ${this._shader.vertexSource}`);
            }
            if (attrib.size !== attribute[1]) {
                throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`
                    + ` doesnt match shader source size ${attrib.size}:\n ${this._shader.vertexSource}`);
            }
            this._layout.push(attrib);
        }
        // calc size
        let componentsPerVertex = 0;
        for (const vertAttribute of this._layout) {
            const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);
            this._vertexTotalSizeBytes += typeSize * vertAttribute.size;
            componentsPerVertex += vertAttribute.size;
        }
        if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {
            this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`
                + ` (${this._vertexBuffer.bufferData.length})`);
        }
    }
    /**
     * Bind this layout with it's associated vertex buffer
     *
     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
     */
    use(uploadBuffer = false, count) {
        const gl = this._gl;
        if (!this._shader.isCurrentlyBound()) {
            throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');
        }
        this._vertexBuffer.bind();
        if (uploadBuffer) {
            this._vertexBuffer.upload(count);
        }
        let offset = 0;
        // TODO switch to VAOs if the extension is
        for (const vert of this._layout) {
            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
            gl.enableVertexAttribArray(vert.location);
            offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-renderer.ts




class LineRenderer {
    constructor() {
        this.type = 'ex.line';
        this.priority = 0;
        this._maxLines = 10922;
        this._vertexIndex = 0;
        this._lineCount = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            vertexSource: line_vertex,
            fragmentSource: line_fragment
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._vertexBuffer = new VertexBuffer({
            size: 6 * 2 * this._maxLines,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            vertexBuffer: this._vertexBuffer,
            shader: this._shader,
            attributes: [
                ['a_position', 2],
                ['a_color', 4]
            ]
        });
    }
    draw(start, end, color) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._lineCount++;
        const transform = this._context.getTransform();
        const finalStart = transform.multiply(start);
        const finalEnd = transform.multiply(end);
        const vertexBuffer = this._vertexBuffer.bufferData;
        // Start
        vertexBuffer[this._vertexIndex++] = finalStart.x;
        vertexBuffer[this._vertexIndex++] = finalStart.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        // End
        vertexBuffer[this._vertexIndex++] = finalEnd.x;
        vertexBuffer[this._vertexIndex++] = finalEnd.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
    }
    _isFull() {
        if (this._lineCount >= this._maxLines) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._lineCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._lineCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line
        GraphicsDiagnostics.DrawnImagesCount += this._lineCount;
        GraphicsDiagnostics.DrawCallCount++;
        // reset
        this._vertexIndex = 0;
        this._lineCount = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-vertex.glsl
/* harmony default export */ const point_vertex = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\nin float a_size;\r\nout lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-fragment.glsl
/* harmony default export */ const point_fragment = ("#version 300 es\r\n\r\nprecision mediump float;\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n  // \"premultiply\" the color by alpha\r\n  vec4 color = v_color;\r\n  color.a = color.a * alpha;\r\n  color.rgb = color.rgb * color.a;\r\n  fragColor = color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-renderer.ts







class PointRenderer {
    constructor() {
        this.type = 'ex.point';
        this.priority = 0;
        this._maxPoints = 10922;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            vertexSource: point_vertex,
            fragmentSource: point_fragment
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._buffer = new VertexBuffer({
            size: 7 * this._maxPoints,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_color', 4],
                ['a_size', 1]
            ]
        });
    }
    draw(point, color, size) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._pointCount++;
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const finalPoint = transform.multiply(point);
        if (snapToPixel) {
            finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);
            finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);
        }
        const vertexBuffer = this._buffer.bufferData;
        vertexBuffer[this._vertexIndex++] = finalPoint.x;
        vertexBuffer[this._vertexIndex++] = finalPoint.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a * opacity;
        vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());
    }
    _isFull() {
        if (this._pointCount >= this._maxPoints) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._pointCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._pointCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.POINTS, 0, this._pointCount);
        GraphicsDiagnostics.DrawnImagesCount += this._pointCount;
        GraphicsDiagnostics.DrawCallCount++;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-vertex.glsl
/* harmony default export */ const screen_vertex = ("#version 300 es\r\nin vec2 a_position;\r\n\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n  gl_Position = vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texcoord to the fragment shader.\r\n  v_texcoord = a_texcoord;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-fragment.glsl
/* harmony default export */ const screen_fragment = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// The texture.\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   fragColor = texture(u_texture, v_texcoord);\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-pass-painter.ts





/**
 * This is responsible for painting the entire screen during the render passes
 */
class ScreenPassPainter {
    constructor(gl) {
        this._gl = gl;
        this._shader = new Shader({
            vertexSource: screen_vertex,
            fragmentSource: screen_fragment
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new VertexBuffer({
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                1, 1, 1, 1
            ])
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_texcoord', 2]
            ]
        });
        this._buffer.upload();
    }
    renderWithPostProcessor(postprocessor) {
        const gl = this._gl;
        postprocessor.getShader().use();
        postprocessor.getLayout().use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    renderToScreen() {
        const gl = this._gl;
        this._shader.use();
        this._layout.use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/quad-index-buffer.ts


/**
 * Helper that defines and index buffer for quad geometry
 *
 * Index buffers allow you to save space in vertex buffers when you share vertices in geometry
 * it is almost always worth it in terms of performance to use an index buffer.
 */
class QuadIndexBuffer {
    /**
     * @param numberOfQuads Specify the max number of quads you want to draw
     * @param useUint16 Optionally force a uint16 buffer
     */
    constructor(numberOfQuads, useUint16) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this._logger = Logger.getInstance();
        const gl = this._gl;
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        const totalVertices = numberOfQuads * 6;
        if (!useUint16) {
            this.bufferData = new Uint32Array(totalVertices);
        }
        else {
            // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck
            const maxUint16 = 65535;
            const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads
            this.bufferGlType = gl.UNSIGNED_SHORT;
            this.bufferData = new Uint16Array(totalVertices);
            // TODO Should we error if this happens?? maybe not might crash mid game
            if (numberOfQuads > maxUint16Index) {
                this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);
            }
        }
        let currentQuad = 0;
        for (let i = 0; i < totalVertices; i += 6) {
            // first triangle
            this.bufferData[i + 0] = currentQuad + 0;
            this.bufferData[i + 1] = currentQuad + 1;
            this.bufferData[i + 2] = currentQuad + 2;
            // second triangle
            this.bufferData[i + 3] = currentQuad + 2;
            this.bufferData[i + 4] = currentQuad + 1;
            this.bufferData[i + 5] = currentQuad + 3;
            currentQuad += 4;
        }
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    get size() {
        return this.bufferData.length;
    }
    /**
     * Upload data to the GPU
     */
    upload() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    /**
     * Bind this index buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.frag.glsl
/* harmony default export */ const image_renderer_frag = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_texcoord;\r\n\r\n// Texture index\r\nin lowp float v_textureIndex;\r\n\r\n// Textures in the current draw\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nin vec4 v_tint;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color = vec4(1.0, 0, 0, 1.0);\r\n\r\n   // GLSL is templated out to pick the right texture and set the vec4 color\r\n   %%texture_picker%%\r\n\r\n   color.rgb = color.rgb * v_opacity;\r\n   color.a = color.a * v_opacity;\r\n   fragColor = color * v_tint;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.vert.glsl
/* harmony default export */ const image_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\n// UV coordinate\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\n// Texture number\r\nin lowp float a_textureIndex;\r\nout lowp float v_textureIndex;\r\n\r\nin vec4 a_tint;\r\nout vec4 v_tint;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the tint\r\n   v_tint = a_tint;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.ts










class ImageRenderer {
    constructor() {
        this.type = 'ex.image';
        this.priority = 0;
        this._maxImages = 10922; // max(uint16) / 6 verts
        this._maxTextures = 0;
        // Per flush vars
        this._imageCount = 0;
        this._textures = [];
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // Transform shader source
        // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...
        this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);
        const transformedFrag = this._transformFragmentSource(image_renderer_frag, this._maxTextures);
        // Compile shader
        this._shader = new Shader({
            fragmentSource: transformedFrag,
            vertexSource: image_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        this._shader.setUniformIntArray('u_textures', [...Array(this._maxTextures)].map((_, i) => i));
        // Setup memory layout
        this._buffer = new VertexBuffer({
            size: 10 * 4 * this._maxImages,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_opacity', 1],
                ['a_texcoord', 2],
                ['a_textureIndex', 1],
                ['a_tint', 4]
            ]
        });
        // Setup index buffer
        this._quads = new QuadIndexBuffer(this._maxImages, true);
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    _addImageAsTexture(image) {
        const texture = TextureLoader.load(image);
        if (this._textures.indexOf(texture) === -1) {
            this._textures.push(texture);
        }
    }
    _bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this._maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
        }
    }
    _getTextureIdForImage(image) {
        if (image) {
            return this._textures.indexOf(TextureLoader.get(image));
        }
        return -1;
    }
    _isFull() {
        if (this._imageCount >= this._maxImages) {
            return true;
        }
        if (this._textures.length >= this._maxTextures) {
            return true;
        }
        return false;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        var _a, _b, _c, _d;
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._imageCount++;
        this._addImageAsTexture(image);
        let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];
        let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];
            dest = [dx, dy];
            width = dwidth;
            height = dheight;
        }
        sx = view[0];
        sy = view[1];
        const sw = view[2];
        const sh = view[3];
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        let topLeft = vec(dest[0], dest[1]);
        let topRight = vec(dest[0] + width, dest[1]);
        let bottomLeft = vec(dest[0], dest[1] + height);
        let bottomRight = vec(dest[0] + width, dest[1] + height);
        topLeft = transform.multiply(topLeft);
        topRight = transform.multiply(topRight);
        bottomLeft = transform.multiply(bottomLeft);
        bottomRight = transform.multiply(bottomRight);
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        const tint = this._context.tint;
        const textureId = this._getTextureIdForImage(image);
        const imageWidth = image.width || width;
        const imageHeight = image.height || height;
        const uvx0 = (sx) / imageWidth;
        const uvy0 = (sy) / imageHeight;
        const uvx1 = (sx + sw - 0.01) / imageWidth;
        const uvy1 = (sy + sh - 0.01) / imageHeight;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
    }
    hasPendingDraws() {
        return this._imageCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._imageCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true, 4 * 10 * this._imageCount);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind textures to
        this._bindTextures(gl);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._imageCount = 0;
        this._vertexIndex = 0;
        this._textures.length = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl
/* harmony default export */ const rectangle_renderer_frag = ("#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\nin vec2 v_size; // in pixels\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness; // in pixels\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    vec2 uv = v_uv;\r\n    vec2 fragCoord = uv * v_size;\r\n    float maxX = v_size.x - v_strokeThickness;\r\n    float minX = v_strokeThickness;\r\n    float maxY = v_size.y - v_strokeThickness;\r\n    float minY = v_strokeThickness;\r\n\r\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\r\n        fragCoord.y < maxY && fragCoord.y > minY) {\r\n      fragColor = v_color;\r\n    } else {\r\n      fragColor = v_strokeColor;\r\n    }\r\n    fragColor.a *= v_opacity;\r\n    fragColor.rgb *= fragColor.a;\r\n\r\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\r\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\r\n\r\n    // float fHalfBorderDist      = 0.0;\r\n    // float fHalfBorderThickness = 0.0;\r\n\r\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \r\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \r\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else\r\n    // {\r\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\r\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\r\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\r\n        \r\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\r\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\r\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \r\n            \r\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\r\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\r\n    // }\r\n\r\n    // vec4 v4FromColor = v_strokeColor;\r\n    // v4FromColor.rgb *= v4FromColor.a;\r\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\r\n    // if (fHalfBorderDist < 0.0) {\r\n    //     v4ToColor = v_color;\r\n    //     v4ToColor.rgb *= v4ToColor.a;\r\n    // }\r\n\r\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\r\n\r\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\r\n    // gl_FragColor = finalColor;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl
/* harmony default export */ const rectangle_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\nin vec2 a_size;\r\nout vec2 v_size;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through size\r\n   v_size = a_size;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.ts










class RectangleRenderer {
    constructor() {
        this.type = 'ex.rectangle';
        this.priority = 0;
        this._maxRectangles = 10922; // max(uint16) / 6 verts
        this._rectangleCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border
        this._shader = new Shader({
            fragmentSource: rectangle_renderer_frag,
            vertexSource: rectangle_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new VertexBuffer({
            size: 16 * 4 * this._maxRectangles,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_size', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new QuadIndexBuffer(this._maxRectangles, true);
    }
    _isFull() {
        if (this._rectangleCount >= this._maxRectangles) {
            return true;
        }
        return false;
    }
    draw(...args) {
        if (args[0] instanceof Vector && args[1] instanceof Vector) {
            this.drawLine.apply(this, args);
        }
        else {
            this.drawRectangle.apply(this, args);
        }
    }
    drawLine(start, end, color, thickness = 1) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const dir = end.sub(start);
        const length = dir.size;
        const normal = dir.normalize().perpendicular();
        const halfThick = thickness / 2;
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startx, starty)------------------>(endx, endy)
         *    |                                            |
         *    + -------------------------------------------+
         */
        const startTop = transform.multiply(normal.scale(halfThick).add(start));
        const startBottom = transform.multiply(normal.scale(-halfThick).add(start));
        const endTop = transform.multiply(normal.scale(halfThick).add(end));
        const endBottom = transform.multiply(normal.scale(-halfThick).add(end));
        if (snapToPixel) {
            startTop.x = ~~(startTop.x + pixelSnapEpsilon);
            startTop.y = ~~(startTop.y + pixelSnapEpsilon);
            endTop.x = ~~(endTop.x + pixelSnapEpsilon);
            endTop.y = ~~(endTop.y + pixelSnapEpsilon);
            startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);
            startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);
            endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);
            endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        const stroke = Color.Transparent;
        const strokeThickness = 0;
        const width = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = startTop.x;
        vertexBuffer[this._vertexIndex++] = startTop.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = startBottom.x;
        vertexBuffer[this._vertexIndex++] = startBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = endTop.x;
        vertexBuffer[this._vertexIndex++] = endTop.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = endBottom.x;
        vertexBuffer[this._vertexIndex++] = endBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    }
    drawRectangle(pos, width, height, color, stroke = Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add(vec(0, 0)));
        const topRight = transform.multiply(pos.add(vec(width, 0)));
        const bottomRight = transform.multiply(pos.add(vec(width, height)));
        const bottomLeft = transform.multiply(pos.add(vec(0, height)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
    }
    hasPendingDraws() {
        return this._rectangleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._rectangleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._rectangleCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.frag.glsl
/* harmony default export */ const circle_renderer_frag = ("#version 300 es\r\nprecision highp float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness;\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  // make (0, 0) the center the uv \r\n  vec2 uv = v_uv * 2.0 - 1.0;\r\n\r\n  vec4 color = v_color;\r\n  vec4 strokeColor = v_strokeColor;\r\n\r\n  // circle border is at radius 1.0 \r\n  // dist is > 0 when inside the circle \r\n  float d = length(uv);\r\n  float dist = 1.0 - length(uv);\r\n\r\n  // Fade based on fwidth\r\n  float fade = fwidth(dot(uv, uv));\r\n\r\n  // if dist is greater than 0 step to 1;\r\n  // when we cross this 0 threshold add a smooth fade\r\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\r\n\r\n  // if dist is greater than the stroke thickness step to 1\r\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\r\n\r\n  strokeColor.a *= fill * stroke;\r\n  strokeColor.rgb *= strokeColor.a;\r\n\r\n  color.a *= fill * (1.0 - stroke);\r\n  color.rgb *= color.a;\r\n\r\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\r\n  finalColor.rgb = finalColor.rgb * v_opacity;\r\n  finalColor.a = finalColor.a * v_opacity;\r\n  fragColor = finalColor;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.vert.glsl
/* harmony default export */ const circle_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.ts










class CircleRenderer {
    constructor() {
        this.type = 'ex.circle';
        this.priority = 0;
        this._maxCircles = 10922; // max(uint16) / 6 verts
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            fragmentSource: circle_renderer_frag,
            vertexSource: circle_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new VertexBuffer({
            size: 14 * 4 * this._maxCircles,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new QuadIndexBuffer(this._maxCircles, true);
    }
    _isFull() {
        if (this._circleCount >= this._maxCircles) {
            return true;
        }
        return false;
    }
    draw(pos, radius, color, stroke = Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._circleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));
        const topRight = transform.multiply(pos.add(vec(radius, -radius)));
        const bottomRight = transform.multiply(pos.add(vec(radius, radius)));
        const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        // TODO UV could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    }
    hasPendingDraws() {
        return this._circleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._circleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._circleCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Util/Pool.ts

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this.disableWarnings = false;
        this._logger = Logger.getInstance();
    }
    preallocate() {
        for (let i = 0; i < this.maxObjects; i++) {
            this.objects[i] = this.builder();
        }
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
        if (this.index === this.maxObjects) {
            if (!this.disableWarnings) {
                this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            }
            this.maxObjects = this.maxObjects * 2;
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            return this.recycler(this.objects[this.index++], ...args);
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder(...args));
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support
            this.totalAllocations++;
        }
        return objects;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/draw-call.ts


class DrawCall {
    constructor() {
        this.z = 0;
        this.priority = 0;
        this.transform = AffineMatrix.identity();
        this.state = {
            z: 0,
            opacity: 1,
            tint: Color.White
        };
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts










// renderers









const pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
        this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });
        this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });
        this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });
        this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._webglCtx.draw('ex.line', start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._webglCtx.draw('ex.point', point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    constructor(options) {
        this._logger = Logger.getInstance();
        this._renderers = new Map();
        this._isDrawLifecycle = false;
        this.useDrawSorting = true;
        this._drawCallPool = new Pool(() => new DrawCall(), (instance) => {
            instance.priority = 0;
            instance.z = 0;
            instance.renderer = undefined;
            instance.args = undefined;
            return instance;
        }, 4000);
        this._drawCalls = [];
        // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process
        this._postProcessTargets = [];
        this._postprocessors = [];
        this._transform = new TransformStack();
        this._state = new StateStack();
        this.snapToPixel = false;
        this.smoothing = false;
        this.backgroundColor = Color.ExcaliburBlue;
        this._alreadyWarnedDrawLifecycle = false;
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;
        this.__gl = canvasElement.getContext('webgl2', {
            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
            premultipliedAlpha: false,
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
            depth: true,
            powerPreference: 'high-performance'
            // TODO Chromium fixed the bug where this didn't work now it breaks CI :(
            // failIfMajorPerformanceCaveat: true
        });
        if (!this.__gl) {
            throw Error('Failed to retrieve webgl context from browser');
        }
        ExcaliburWebGLContextAccessor.register(this.__gl);
        TextureLoader.register(this.__gl);
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;
        this._drawCallPool.disableWarnings = true;
        this._drawCallPool.preallocate();
        this._init();
    }
    get z() {
        return this._state.current.z;
    }
    set z(value) {
        this._state.current.z = value;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    get ortho() {
        return this._ortho;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        let supported = true;
        if (dim.width > 4096 || dim.height > 4096) {
            supported = false;
        }
        return supported;
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        // Setup builtin renderers
        this.register(new ImageRenderer());
        this.register(new RectangleRenderer());
        this.register(new CircleRenderer());
        this.register(new PointRenderer());
        this.register(new LineRenderer());
        this._screenRenderer = new ScreenPassPainter(gl);
        this._renderTarget = new RenderTarget({
            gl,
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this._postProcessTargets = [
            new RenderTarget({
                gl,
                width: gl.canvas.width,
                height: gl.canvas.height
            }),
            new RenderTarget({
                gl,
                width: gl.canvas.width,
                height: gl.canvas.height
            })
        ];
    }
    register(renderer) {
        this._renderers.set(renderer.type, renderer);
        renderer.initialize(this.__gl, this);
    }
    get(rendererName) {
        return this._renderers.get(rendererName);
    }
    _isCurrentRenderer(renderer) {
        if (!this._currentRenderer || this._currentRenderer === renderer) {
            return true;
        }
        return false;
    }
    beginDrawLifecycle() {
        this._isDrawLifecycle = true;
    }
    endDrawLifecycle() {
        this._isDrawLifecycle = false;
    }
    draw(rendererName, ...args) {
        if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {
            this._logger.warn(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\n` +
                `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);
            this._alreadyWarnedDrawLifecycle = true;
        }
        const renderer = this._renderers.get(rendererName);
        if (renderer) {
            if (this.useDrawSorting) {
                const drawCall = this._drawCallPool.get();
                drawCall.z = this._state.current.z;
                drawCall.priority = renderer.priority;
                drawCall.renderer = rendererName;
                this.getTransform().clone(drawCall.transform);
                drawCall.state.z = this._state.current.z;
                drawCall.state.opacity = this._state.current.opacity;
                drawCall.state.tint = this._state.current.tint;
                drawCall.args = args;
                this._drawCalls.push(drawCall);
            }
            else {
                // Set the current renderer if not defined
                if (!this._currentRenderer) {
                    this._currentRenderer = renderer;
                }
                if (!this._isCurrentRenderer(renderer)) {
                    // switching graphics means we must flush the previous
                    this._currentRenderer.flush();
                }
                // If we are still using the same renderer we can add to the current batch
                renderer.draw(...args);
                this._currentRenderer = renderer;
            }
        }
        else {
            throw Error(`No renderer with name ${rendererName} has been registered`);
        }
    }
    resetTransform() {
        this._transform.current = AffineMatrix.identity();
    }
    updateViewport(resolution) {
        const gl = this.__gl;
        this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);
        this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        this.draw('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    drawLine(start, end, color, thickness = 1) {
        this.draw('ex.rectangle', start, end, color, thickness);
    }
    drawRectangle(pos, width, height, color, stroke, strokeThickness) {
        this.draw('ex.rectangle', pos, width, height, color, stroke, strokeThickness);
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.draw('ex.circle', pos, radius, color, stroke, thickness);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    getTransform() {
        return this._transform.current;
    }
    multiply(m) {
        this._transform.current.multiply(m, this._transform.current);
    }
    addPostProcessor(postprocessor) {
        this._postprocessors.push(postprocessor);
        postprocessor.initialize(this.__gl);
    }
    removePostProcessor(postprocessor) {
        const index = this._postprocessors.indexOf(postprocessor);
        if (index !== -1) {
            this._postprocessors.splice(index, 1);
        }
    }
    clearPostProcessors() {
        this._postprocessors.length = 0;
    }
    clear() {
        const gl = this.__gl;
        this._renderTarget.use();
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        const gl = this.__gl;
        // render target captures all draws and redirects to the render target
        this._renderTarget.use();
        if (this.useDrawSorting) {
            // sort draw calls
            // Find the original order of the first instance of the draw call
            const originalSort = new Map();
            for (const [name] of this._renderers) {
                const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);
                originalSort.set(name, firstIndex);
            }
            this._drawCalls.sort((a, b) => {
                const zIndex = a.z - b.z;
                const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);
                const priority = a.priority - b.priority;
                if (zIndex === 0) { // sort by z first
                    if (priority === 0) { // sort by priority
                        return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order
                    }
                    return priority;
                }
                return zIndex;
            });
            const oldTransform = this._transform.current;
            const oldState = this._state.current;
            if (this._drawCalls.length) {
                let currentRendererName = this._drawCalls[0].renderer;
                let currentRenderer = this._renderers.get(currentRendererName);
                for (let i = 0; i < this._drawCalls.length; i++) {
                    // hydrate the state for renderers
                    this._transform.current = this._drawCalls[i].transform;
                    this._state.current = this._drawCalls[i].state;
                    if (this._drawCalls[i].renderer !== currentRendererName) {
                        // switching graphics renderer means we must flush the previous
                        currentRenderer.flush();
                        currentRendererName = this._drawCalls[i].renderer;
                        currentRenderer = this._renderers.get(currentRendererName);
                    }
                    // If we are still using the same renderer we can add to the current batch
                    currentRenderer.draw(...this._drawCalls[i].args);
                }
                if (currentRenderer.hasPendingDraws()) {
                    currentRenderer.flush();
                }
            }
            // reset state
            this._transform.current = oldTransform;
            this._state.current = oldState;
            // reclaim draw calls
            this._drawCallPool.done();
            this._drawCalls.length = 0;
        }
        else {
            // This is the final flush at the moment to draw any leftover pending draw
            for (const renderer of this._renderers.values()) {
                if (renderer.hasPendingDraws()) {
                    renderer.flush();
                }
            }
        }
        this._renderTarget.disable();
        // post process step
        const source = this._renderTarget.toRenderSource();
        source.use();
        // flip flop render targets
        for (let i = 0; i < this._postprocessors.length; i++) {
            this._postProcessTargets[i % 2].use();
            this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);
            this._postProcessTargets[i % 2].toRenderSource().use();
        }
        // passing null switches rendering back to the canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._screenRenderer.renderToScreen();
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts




const ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this._ex.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y, this._ex.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = lineOptions.color.toString();
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.x, this._ex.snapToPixel ? ~~(point.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    constructor(options) {
        /**
         * Unused in Canvas implementation
         */
        this.useDrawSorting = false;
        /**
         * Unused in Canvas implementation
         */
        this.z = 0;
        this.backgroundColor = Color.ExcaliburBlue;
        this._state = new StateStack();
        this.snapToPixel = false;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
        this.__ctx = canvasElement.getContext('2d', {
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
        });
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport(_resolution) {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        GraphicsDiagnostics.DrawCallCount++;
        GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.__ctx.save();
        this.__ctx.beginPath();
        if (stroke) {
            this.__ctx.strokeStyle = stroke.toString();
        }
        if (thickness) {
            this.__ctx.lineWidth = thickness;
        }
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        if (stroke) {
            this.__ctx.stroke();
        }
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    getTransform() {
        throw new Error('Not implemented');
    }
    multiply(_m) {
        this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));
    }
    addPostProcessor(_postprocessor) {
        // pass
    }
    removePostProcessor(_postprocessor) {
        // pass
    }
    clearPostProcessors() {
        // pass
    }
    beginDrawLifecycle() {
        // pass
    }
    endDrawLifecycle() {
        // pass
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
}

;// CONCATENATED MODULE: ./Screen.ts






/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.
     * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]
     * is guaranteed to be on screen.
     */
    DisplayMode["FitContainerAndFill"] = "FitContainerAndFill";
    /**
     * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.
     * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]
     * is guaranteed to be on screen.
     */
    DisplayMode["FitScreenAndFill"] = "FitScreenAndFill";
    /**
     * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in [[FitContainer]].
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use [[Screen.contentArea]] to know the safe to draw area.
     */
    DisplayMode["FitContainerAndZoom"] = "FitContainerAndZoom";
    /**
     * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in [[FitScreen]].
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use [[Screen.contentArea]] to know the safe to draw area.
     */
    DisplayMode["FitScreenAndZoom"] = "FitScreenAndZoom";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            this._isFullScreen = !this._isFullScreen;
            this._logger.debug('Fullscreen Change', this._isFullScreen);
        };
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._listenForPixelRatio();
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
        };
        this._resizeHandler = () => {
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._alreadyWarned = false;
        this._contentArea = new BoundingBox();
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : { ...this.viewport };
        this._contentResolution = this.resolution;
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this.graphicsContext = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._listenForPixelRatio();
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    _listenForPixelRatio() {
        if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {
            // Safari <=13.1 workaround, remove any existing handlers
            this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
        }
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        // Safari <=13.1 workaround
        if (this._mediaQueryList.addEventListener) {
            this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });
        }
        else {
            this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
        }
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._resizeHandler);
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            // Safari <=13.1 workaround
            if (this._mediaQueryList.removeEventListener) {
                this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            }
            else {
                this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
            }
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        switch (this.displayMode) {
            case DisplayMode.FillContainer:
            case DisplayMode.FitContainer:
            case DisplayMode.FitContainerAndFill:
            case DisplayMode.FitContainerAndZoom:
                return this.canvas.parentElement || document.body;
            default:
                return window;
        }
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = { ...this.resolution };
        this.viewport = { ...this.viewport };
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            const supported = this.graphicsContext.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!supported && !this._alreadyWarned) {
                this._alreadyWarned = true; // warn once
                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +
                    ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
            }
        }
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this.graphicsContext.updateViewport(this.resolution);
        this.graphicsContext.resetTransform();
        this.graphicsContext.smoothing = this._antialiasing;
        if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {
            this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);
        }
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this.graphicsContext.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreen using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     *
     * Optionally specify a target element id to go fullscreen, by default the game canvas is used
     * @param elementId
     */
    goFullScreen(elementId) {
        if (elementId) {
            const maybeElement = document.getElementById(elementId);
            if (maybeElement) {
                return maybeElement.requestFullscreen();
            }
        }
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullScreen) {
            newX -= getPosition(this._canvas).x;
            newY -= getPosition(this._canvas).y;
        }
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;
                newX = (newX / window.innerWidth) * this.viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;
                newY = (newY / window.innerHeight) * this.viewport.height;
            }
        }
        newX = (newX / this.viewport.width) * this.resolution.width;
        newY = (newY / this.viewport.height) * this.resolution.height;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        newX = (newX / this.resolution.width) * this.viewport.width;
        newY = (newY / this.resolution.height) * this.viewport.height;
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;
                newX = (newX / this.viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;
                newY = (newY / this.viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullScreen) {
            newX += getPosition(this._canvas).x;
            newY += getPosition(this._canvas).y;
        }
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        // the only difference between screen & world is the camera transform
        if (this._camera) {
            return this._camera.inverse.multiply(point);
        }
        return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        if (this._camera) {
            return this._camera.transform.multiply(point);
        }
        return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
        const topLeft = this.screenToWorldCoordinates(Vector.Zero);
        const right = topLeft.x + this.drawWidth;
        const bottom = topLeft.y + this.drawHeight;
        return new BoundingBox(topLeft.x, topLeft.y, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    /**
     * Returns the content area in screen space where it is safe to place content
     */
    get contentArea() {
        return this._contentArea;
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _computeFitScreenAndFill() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndFill(vw, vh);
    }
    _computeFitContainerAndFill() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const parent = this.canvas.parentElement;
        const vw = parent.clientWidth;
        const vh = parent.clientHeight;
        this._computeFitAndFill(vw, vh);
    }
    _computeFitAndFill(vw, vh) {
        this.viewport = {
            width: vw,
            height: vh
        };
        // if the current screen aspectRatio is less than the original aspectRatio
        if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {
            // compute new resolution to match the original aspect ratio
            this.resolution = {
                width: vw * this._contentResolution.width / vw,
                height: vw * this._contentResolution.width / vw * vh / vw
            };
            const clip = (this.resolution.height - this._contentResolution.height) / 2;
            this._contentArea = new BoundingBox({
                top: clip,
                left: 0,
                right: this._contentResolution.width,
                bottom: this.resolution.height - clip
            });
        }
        else {
            this.resolution = {
                width: vh * this._contentResolution.height / vh * vw / vh,
                height: vh * this._contentResolution.height / vh
            };
            const clip = (this.resolution.width - this._contentResolution.width) / 2;
            this._contentArea = new BoundingBox({
                top: 0,
                left: clip,
                right: this.resolution.width - clip,
                bottom: this._contentResolution.height
            });
        }
    }
    _computeFitScreenAndZoom() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        this.canvas.style.position = 'absolute';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndZoom(vw, vh);
    }
    _computeFitContainerAndZoom() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        this.canvas.style.position = 'absolute';
        const parent = this.canvas.parentElement;
        parent.style.position = 'relative';
        parent.style.overflow = 'hidden';
        const vw = parent.clientWidth;
        const vh = parent.clientHeight;
        this._computeFitAndZoom(vw, vh);
    }
    _computeFitAndZoom(vw, vh) {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (vw / aspect < vh) {
            adjustedWidth = vw;
            adjustedHeight = vw / aspect;
        }
        else {
            adjustedWidth = vh * aspect;
            adjustedHeight = vh;
        }
        const scaleX = vw / adjustedWidth;
        const scaleY = vh / adjustedHeight;
        const maxScaleFactor = Math.max(scaleX, scaleY);
        const zoomedWidth = adjustedWidth * maxScaleFactor;
        const zoomedHeight = adjustedHeight * maxScaleFactor;
        // Center zoomed dimension if bigger than the screen
        if (zoomedWidth > vw) {
            this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';
        }
        else {
            this.canvas.style.left = '';
        }
        if (zoomedHeight > vh) {
            this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';
        }
        else {
            this.canvas.style.top = '';
        }
        this.viewport = {
            width: zoomedWidth,
            height: zoomedHeight
        };
        const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);
        // return safe area
        if (this.viewport.width > vw) {
            const clip = (this.viewport.width - vw) / this.viewport.width * this.resolution.width;
            bounds.top = 0;
            bounds.left = clip / 2;
            bounds.right = this.resolution.width - clip / 2;
            bounds.bottom = this.resolution.height;
        }
        if (this.viewport.height > vh) {
            const clip = (this.viewport.height - vh) / this.viewport.height * this.resolution.height;
            bounds.top = clip / 2;
            bounds.left = 0;
            bounds.bottom = this.resolution.height - clip / 2;
            bounds.right = this.resolution.width;
        }
        this._contentArea = bounds;
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            adjustedWidth = parent.clientWidth;
            adjustedHeight = parent.clientWidth / aspect;
        }
        else {
            adjustedWidth = parent.clientHeight * aspect;
            adjustedHeight = parent.clientHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _applyDisplayMode() {
        this._setResolutionAndViewportByDisplayMode(this.parent);
        // watch resizing
        if (this.parent instanceof Window) {
            this._browser.window.on('resize', this._resizeHandler);
        }
        else {
            this._resizeObserver = new ResizeObserver(() => {
                this._resizeHandler();
            });
            this._resizeObserver.observe(this.parent);
        }
        this.parent.addEventListener('resize', this._resizeHandler);
    }
    /**
     * Sets the resolution and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
        if (this.displayMode === DisplayMode.FitScreenAndFill) {
            this._computeFitScreenAndFill();
        }
        if (this.displayMode === DisplayMode.FitContainerAndFill) {
            this._computeFitContainerAndFill();
        }
        if (this.displayMode === DisplayMode.FitScreenAndZoom) {
            this._computeFitScreenAndZoom();
        }
        if (this.displayMode === DisplayMode.FitContainerAndZoom) {
            this._computeFitContainerAndZoom();
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;

;// CONCATENATED MODULE: ./Util/WebAudio.ts


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;

;// CONCATENATED MODULE: ./Class.ts

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new EventDispatcher();
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}

;// CONCATENATED MODULE: ./Util/DrawUtil.ts

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Loader.logo.png
/* harmony default export */ const Loader_logo = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");
// EXTERNAL MODULE: ./Loader.css
var Loader_0 = __webpack_require__(1388);
;// CONCATENATED MODULE: ./Graphics/Raster.ts






/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.
 */
class Raster extends Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super(options);
        this.filtering = null;
        this.lineCap = 'butt';
        this.quality = 1;
        this._dirty = true;
        this._smoothing = false;
        this._color = watch(Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;
            this.color = (_b = options.color) !== null && _b !== void 0 ? _b : Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;
            this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;
            this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
            this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;
            this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;
            this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;
        const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;
        this.width = bitmapWidth;
        this.height = bitmapHeight;
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : null,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            lineCap: this.lineCap,
            quality: this.quality,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputted drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s or `quality` set will be factored into the width
     */
    get width() {
        return Math.abs(this._getTotalWidth() * this.scale.x);
    }
    set width(value) {
        value /= Math.abs(this.scale.x);
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` or `quality` set will be factored into the height
     */
    get height() {
        return Math.abs(this._getTotalHeight() * this.scale.y);
    }
    set height(value) {
        value /= Math.abs(this.scale.y);
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;
    }
    _getTotalHeight() {
        var _a;
        return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        this.flagDirty();
        this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        this.flagDirty();
        this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperties(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
        // The webgl texture needs to be updated if it exists after a raster cycle
        TextureLoader.load(this._bitmap, this.filtering, true);
    }
    _applyRasterProperties(ctx) {
        var _a, _b, _c;
        this._bitmap.width = this._getTotalWidth() * this.quality;
        this._bitmap.height = this._getTotalHeight() * this.quality;
        ctx.scale(this.quality, this.quality);
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.lineCap = this.lineCap;
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.scale(1 / this.quality, 1 / this.quality);
        ex.drawImage(this._bitmap, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Canvas.ts

/**
 * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].
 *
 * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends Raster {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    clone() {
        return new Canvas({
            ...this._options,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}

;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};

;// CONCATENATED MODULE: ./Util/StateMachine.ts
class StateMachine {
    constructor() {
        this.states = new Map();
    }
    get currentState() {
        return this._currentState;
    }
    set currentState(state) {
        this._currentState = state;
    }
    static create(machineDescription, data) {
        const machine = new StateMachine();
        machine.data = data;
        for (const stateName in machineDescription.states) {
            machine.states.set(stateName, {
                name: stateName,
                ...machineDescription.states[stateName]
            });
        }
        // validate transitions are states
        for (const state of machine.states.values()) {
            for (const transitionState of state.transitions) {
                if (transitionState === '*') {
                    continue;
                }
                if (!machine.states.has(transitionState)) {
                    throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);
                }
            }
        }
        machine.currentState = machine.startState = machine.states.get(machineDescription.start);
        return machine;
    }
    in(state) {
        return this.currentState.name === state;
    }
    go(stateName, eventData) {
        var _a, _b;
        if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {
            const potentialNewState = this.states.get(stateName);
            if (this.currentState.onExit) {
                const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });
                if (canExit === false) {
                    return false;
                }
            }
            if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {
                const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });
                if (canEnter === false) {
                    return false;
                }
            }
            // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);
            this.currentState = potentialNewState;
            if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) {
                this.currentState.onState();
            }
            return true;
        }
        return false;
    }
    update(elapsedMs) {
        if (this.currentState.onUpdate) {
            this.currentState.onUpdate(this.data, elapsedMs);
        }
    }
    save(saveKey) {
        localStorage.setItem(saveKey, JSON.stringify({
            currentState: this.currentState.name,
            data: this.data
        }));
    }
    restore(saveKey) {
        const state = JSON.parse(localStorage.getItem(saveKey));
        this.currentState = this.states.get(state.currentState);
        this.data = state.data;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts



/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._audioContext = AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        this._stateMachine = StateMachine.create({
            start: 'STOPPED',
            states: {
                PLAYING: {
                    onEnter: ({ data }) => {
                        // Buffer nodes are single use
                        this._createNewBufferSource();
                        this._handleEnd();
                        this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);
                        data.startedAt = (this._audioContext.currentTime - data.pausedAt);
                        data.pausedAt = 0;
                    },
                    onState: () => this._playStarted(),
                    onExit: ({ to }) => {
                        // If you've exited early only resolve if explicitly STOPPED
                        if (to === 'STOPPED') {
                            this._playingResolve(true);
                        }
                        // Whenever you're not playing... you stop!
                        this._instance.onended = null; // disconnect the wired on-end handler
                        this._instance.disconnect();
                        this._instance.stop(0);
                        this._instance = null;
                    },
                    transitions: ['STOPPED', 'PAUSED', 'SEEK']
                },
                SEEK: {
                    onEnter: ({ eventData: position, data }) => {
                        data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;
                        data.startedAt = 0;
                    },
                    transitions: ['*']
                },
                STOPPED: {
                    onEnter: ({ data }) => {
                        data.pausedAt = 0;
                        data.startedAt = 0;
                        this._playingResolve(true);
                    },
                    transitions: ['PLAYING', 'PAUSED', 'SEEK']
                },
                PAUSED: {
                    onEnter: ({ data }) => {
                        // Playback rate will be a scale factor of how fast/slow the audio is being played
                        // default is 1.0
                        // we need to invert it to get the time scale
                        data.pausedAt = (this._audioContext.currentTime - data.startedAt);
                    },
                    transitions: ['PLAYING', 'STOPPED', 'SEEK']
                }
            }
        }, {
            startedAt: 0,
            pausedAt: 0
        });
        this._volume = 1;
        this._loop = false;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._playStarted = () => { };
        this._playbackRate = 1.0;
        this._createNewBufferSource();
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.value = this._playbackRate;
        this._instance.connect(this._volumeNode);
        this._volumeNode.connect(this._audioContext.destination);
    }
    _handleEnd() {
        if (!this.loop) {
            this._instance.onended = () => {
                this._playingResolve(true);
            };
        }
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            if (!this.loop) {
                this._instance.onended = () => {
                    this._playingResolve(true);
                };
            }
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = clamp(value, 0, 1.0);
        this._volume = value;
        if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    /**
     * Returns the set duration to play, otherwise returns the total duration if unset
     */
    get duration() {
        var _a;
        return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();
    }
    /**
     * Set the duration that this audio should play.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    isPlaying() {
        return this._stateMachine.in('PLAYING');
    }
    isPaused() {
        return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        this._playStarted = playStarted;
        this._stateMachine.go('PLAYING');
        return this._playingPromise;
    }
    pause() {
        this._stateMachine.go('PAUSED');
    }
    stop() {
        this._stateMachine.go('STOPPED');
    }
    seek(position) {
        this._stateMachine.go('PAUSED');
        this._stateMachine.go('SEEK', position);
    }
    getTotalPlaybackDuration() {
        return this._src.duration;
    }
    getPlaybackPosition() {
        const { pausedAt, startedAt } = this._stateMachine.data;
        if (pausedAt) {
            return pausedAt * this._playbackRate;
        }
        if (startedAt) {
            return (this._audioContext.currentTime - startedAt) * this._playbackRate;
        }
        return 0;
    }
    set playbackRate(playbackRate) {
        this._instance.playbackRate.value = this._playbackRate = playbackRate;
    }
    get playbackRate() {
        return this._instance.playbackRate.value;
    }
}

;// CONCATENATED MODULE: ./Events/MediaEvents.ts

class MediaEvent extends GameEvent {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}

;// CONCATENATED MODULE: ./Util/Sound.ts

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts








/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends Class {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super();
        this.logger = Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._isStopped = false;
        // private _isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._playbackRate = 1.0;
        this._audioContext = AudioContextFactory.create();
        this._resource = new Resource('', ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (canPlayFile(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    /**
     * Get the duration that this audio should play. If unset the total natural playback duration will be used.
     */
    get duration() {
        return this._duration;
    }
    /**
     * Set the duration that this audio should play. If unset the total natural playback duration will be used.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    isLoaded() {
        return !!this.data;
    }
    async load() {
        var _a, _b;
        if (this.data) {
            return this.data;
        }
        const arraybuffer = await this._resource.load();
        const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));
        this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : undefined;
        this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));
        return this.data = audiobuffer;
    }
    async decodeAudio(data) {
        try {
            return await this._audioContext.decodeAudioData(data.slice(0));
        }
        catch (e) {
            this.logger.error('Unable to decode ' +
                ' this browser may not fully support this format, or the file may be corrupt, ' +
                'if this is an mp3 try removing id3 tags and album art from the file.');
            return await Promise.reject();
        }
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    isPaused() {
        return this._tracks.some(t => t.isPaused());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this.isPaused()) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this.emit('pause', new NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new NativeSoundEvent(this));
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    get playbackRate() {
        return this._playbackRate;
    }
    set playbackRate(playbackRate) {
        this._playbackRate = playbackRate;
        this._tracks.forEach(t => {
            t.playbackRate = this._playbackRate;
        });
    }
    seek(position, trackId = 0) {
        if (this._tracks.length === 0) {
            this._getTrackInstance(this.data);
        }
        this._tracks[trackId].seek(position);
    }
    getTotalPlaybackDuration() {
        return this.data.duration;
    }
    /**
     * Return the current playback time of the playing track in seconds from the start.
     *
     * Optionally specify the track to query if multiple are playing at once.
     * @param trackId
     */
    getPlaybackPosition(trackId = 0) {
        if (this._tracks.length) {
            return this._tracks[trackId].getPlaybackPosition();
        }
        return 0;
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    async _resumePlayback() {
        if (this.isPaused) {
            const resumed = [];
            // ensure we resume *current* tracks (if paused)
            for (const track of this._tracks) {
                resumed.push(track.play().then(() => {
                    this.emit('playbackend', new NativeSoundEvent(this, track));
                    this._tracks.splice(this.getTrackId(track), 1);
                    return true;
                }));
            }
            this.emit('resume', new NativeSoundEvent(this));
            this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
            // resolve when resumed tracks are done
            await Promise.all(resumed);
        }
        return true;
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    async _startPlayback() {
        const track = await this._getTrackInstance(this.data);
        const complete = await track.play(() => {
            this.emit('playbackstart', new NativeSoundEvent(this, track));
            this.logger.debug('Playing new instance for sound', this.path);
        });
        // when done, remove track
        this.emit('playbackend', new NativeSoundEvent(this, track));
        this._tracks.splice(this.getTrackId(track), 1);
        return complete;
    }
    _getTrackInstance(data) {
        const newTrack = new WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        newTrack.playbackRate = this._playbackRate;
        this._tracks.push(newTrack);
        return newTrack;
    }
}

;// CONCATENATED MODULE: ./Loader.ts












/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends Class {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this.canvas = new Canvas({
            filtering: ImageFiltering.Blended,
            smoothing: true,
            cache: true,
            draw: this.draw.bind(this)
        });
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = Loader_logo;
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        this._loadingFuture = new Future();
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
        this.canvas.width = this._engine.canvas.width;
        this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    async showPlayButton() {
        var _a, _b;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            // Delay is to give the logo a chance to show, otherwise don't delay
            await delay(500, (_a = this._engine) === null || _a === void 0 ? void 0 : _a.clock);
        }
        else {
            const resizeHandler = () => {
                this._positionPlayButton();
            };
            if ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.browser) {
                this._engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            this._positionPlayButton();
            const playButtonClicked = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propagation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this._engine.browser.window.off('resize', resizeHandler);
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return await playButtonClicked;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    update(_engine, _delta) {
        // override me
    }
    areResourcesLoaded() {
        return this._loadingFuture.promise;
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete AND the user has clicked the "Play button"
     */
    async load() {
        var _a, _b;
        await ((_a = this._image) === null || _a === void 0 ? void 0 : _a.decode()); // decode logo if it exists
        this.canvas.flagDirty();
        await Promise.all(this._resourceList.map(async (r) => {
            await r.load().finally(() => {
                // capture progress
                this._numLoaded++;
                this.canvas.flagDirty();
            });
        }));
        // Wire all sound to the engine
        for (const resource of this._resourceList) {
            if (resource instanceof Sound) {
                resource.wireEngine(this._engine);
            }
        }
        this._loadingFuture.resolve();
        // short delay in showing the button for aesthetics
        await delay(200, (_b = this._engine) === null || _b === void 0 ? void 0 : _b.clock);
        this.canvas.flagDirty();
        await this.showPlayButton();
        // Unlock browser AudioContext in after user gesture
        // See: https://github.com/excaliburjs/Excalibur/issues/262
        // See: https://github.com/excaliburjs/Excalibur/issues/1031
        await WebAudio.unlock();
        return (this.data = this._resourceList);
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progress of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
        if (this._engine) {
            const screenHeight = this._engine.screen.viewport.height;
            const screenWidth = this._engine.screen.viewport.width;
            if (this._playButtonRootElement) {
                const left = this._engine.canvas.offsetLeft;
                const top = this._engine.canvas.offsetTop;
                const buttonWidth = this._playButton.clientWidth;
                const buttonHeight = this._playButton.clientHeight;
                if (this.playButtonPosition) {
                    this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                    this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
                }
                else {
                    this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                    this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
                }
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
}

;// CONCATENATED MODULE: ./Util/Detector.ts

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // (â)
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // (â)
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionType.ts
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));

;// CONCATENATED MODULE: ./Util/Decorators.ts


const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrace: false,
        ...options
    };
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? { ...descriptor } : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}

;// CONCATENATED MODULE: ./Collision/Physics.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy["Arcade"] = "arcade";
    CollisionResolutionStrategy["Realistic"] = "realistic";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 0] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    static get gravity() {
        return Physics.acc;
    }
    static set gravity(v) {
        Physics.acc = v;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new Vector(0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Number of position iterations (overlap) to run in the solver
 */
Physics.positionIterations = 3;
/**
 * Number of velocity iteration (response) to run in the solver
 */
Physics.velocityIterations = 8;
/**
 * Amount of overlap to tolerate in pixels
 */
Physics.slop = 1;
/**
 * Amount of positional overlap correction to apply each position iteration of the solver
 * O - meaning no correction, 1 - meaning correct all overlap
 */
Physics.steeringFactor = 0.2;
/**
 * Warm start set to true re-uses impulses from previous frames back in the solver
 */
Physics.warmStart = true;
/**
 * By default bodies do not sleep
 */
Physics.bodiesCanSleepByDefault = false;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
Physics.sleepEpsilon = 0.07;
Physics.wakeThreshold = Physics.sleepEpsilon * 3;
Physics.sleepBias = 0.9;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
__decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);

;// CONCATENATED MODULE: ./Math/coord-plane.ts
/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));

;// CONCATENATED MODULE: ./Math/vector-view.ts

class VectorView extends Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}

;// CONCATENATED MODULE: ./Math/watch-vector.ts

/**
 * Wraps a vector and watches for changes in the x/y, modifies the original vector.
 */
class WatchVector extends Vector {
    constructor(original, change) {
        super(original.x, original.y);
        this.original = original;
        this.change = change;
    }
    get x() {
        return this._x = this.original.x;
    }
    set x(newX) {
        this.change(newX, this._y);
        this._x = this.original.x = newX;
    }
    get y() {
        return this._y = this.original.y;
    }
    set y(newY) {
        this.change(this._x, newY);
        this._y = this.original.y = newY;
    }
}

;// CONCATENATED MODULE: ./Math/transform.ts





class Transform {
    constructor() {
        this._parent = null;
        this._children = [];
        this._pos = vec(0, 0);
        this._rotation = 0;
        this._scale = vec(1, 1);
        this._isDirty = false;
        this._isInverseDirty = false;
        this._matrix = AffineMatrix.identity();
        this._inverse = AffineMatrix.identity();
    }
    get parent() {
        return this._parent;
    }
    set parent(transform) {
        if (this._parent) {
            const index = this._parent._children.indexOf(this);
            if (index > -1) {
                this._parent._children.splice(index, 1);
            }
        }
        this._parent = transform;
        if (this._parent) {
            this._parent._children.push(this);
        }
        this.flagDirty();
    }
    get children() {
        return this._children;
    }
    set pos(v) {
        if (!v.equals(this._pos)) {
            this._pos.x = v.x;
            this._pos.y = v.y;
            this.flagDirty();
        }
    }
    get pos() {
        return new WatchVector(this._pos, (x, y) => {
            if (x !== this._pos.x || y !== this._pos.y) {
                this.flagDirty();
            }
        });
    }
    set globalPos(v) {
        let localPos = v.clone();
        if (this.parent) {
            localPos = this.parent.inverse.multiply(v);
        }
        if (!localPos.equals(this._pos)) {
            this._pos = localPos;
            this.flagDirty();
        }
    }
    get globalPos() {
        return new VectorView({
            getX: () => this.matrix.data[4],
            getY: () => this.matrix.data[5],
            setX: (x) => {
                if (this.parent) {
                    const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));
                    this.pos.x = newX;
                }
                else {
                    this.pos.x = x;
                }
                if (x !== this.matrix.data[4]) {
                    this.flagDirty();
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));
                    this.pos.y = newY;
                }
                else {
                    this.pos.y = y;
                }
                if (y !== this.matrix.data[5]) {
                    this.flagDirty();
                }
            }
        });
    }
    set rotation(rotation) {
        const canonRotation = canonicalizeAngle(rotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get rotation() {
        return this._rotation;
    }
    set globalRotation(rotation) {
        let inverseRotation = 0;
        if (this.parent) {
            inverseRotation = this.parent.globalRotation;
        }
        const canonRotation = canonicalizeAngle(rotation + inverseRotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get globalRotation() {
        if (this.parent) {
            return this.matrix.getRotation();
        }
        return this.rotation;
    }
    set scale(v) {
        if (!v.equals(this._scale)) {
            this._scale.x = v.x;
            this._scale.y = v.y;
            this.flagDirty();
        }
    }
    get scale() {
        return new WatchVector(this._scale, (x, y) => {
            if (x !== this._scale.x || y !== this._scale.y) {
                this.flagDirty();
            }
        });
    }
    set globalScale(v) {
        let inverseScale = vec(1, 1);
        if (this.parent) {
            inverseScale = this.parent.globalScale;
        }
        this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));
    }
    get globalScale() {
        return new VectorView({
            getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,
            getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.scale.x = x / globalScaleX;
                }
                else {
                    this.scale.x = x;
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.scale.y = y / globalScaleY;
                }
                else {
                    this.scale.y = y;
                }
            }
        });
    }
    get matrix() {
        if (this._isDirty) {
            if (this.parent === null) {
                this._matrix = this._calculateMatrix();
            }
            else {
                this._matrix = this.parent.matrix.multiply(this._calculateMatrix());
            }
            this._isDirty = false;
        }
        return this._matrix;
    }
    get inverse() {
        if (this._isInverseDirty) {
            this._inverse = this.matrix.inverse();
            this._isInverseDirty = false;
        }
        return this._inverse;
    }
    _calculateMatrix() {
        const matrix = AffineMatrix.identity()
            .translate(this.pos.x, this.pos.y)
            .rotate(this.rotation)
            .scale(this.scale.x, this.scale.y);
        return matrix;
    }
    flagDirty() {
        this._isDirty = true;
        this._isInverseDirty = true;
        for (let i = 0; i < this._children.length; i++) {
            this._children[i].flagDirty();
        }
    }
    apply(point) {
        return this.matrix.multiply(point);
    }
    applyInverse(point) {
        return this.inverse.multiply(point);
    }
    setTransform(pos, rotation, scale) {
        this._pos.x = pos.x;
        this._pos.y = pos.y;
        this._rotation = canonicalizeAngle(rotation);
        this._scale.x = scale.x;
        this._scale.y = scale.y;
        this.flagDirty();
    }
    clone(dest) {
        const target = dest !== null && dest !== void 0 ? dest : new Transform();
        this._pos.clone(target._pos);
        target._rotation = this._rotation;
        this._scale.clone(target._scale);
        target.flagDirty();
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependencies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}

;// CONCATENATED MODULE: ./Util/Observable.ts
/**
 * Simple Observable implementation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        const observersLength = this.observers.length;
        for (let i = 0; i < observersLength; i++) {
            this.observers[i].notify(message);
        }
        const subscriptionsLength = this.subscriptions.length;
        for (let i = 0; i < subscriptionsLength; i++) {
            this.subscriptions[i](message);
        }
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts




class TransformComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.transform';
        this._transform = new Transform();
        this._addChildTransform = (child) => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = this._transform;
            }
        };
        /**
         * Observable that emits when the z index changes on this component
         */
        this.zIndexChanged$ = new Observable();
        this._z = 0;
        /**
         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
    }
    get() {
        return this._transform;
    }
    onAdd(owner) {
        for (const child of owner.children) {
            this._addChildTransform(child);
        }
        owner.childrenAdded$.subscribe(child => this._addChildTransform(child));
        owner.childrenRemoved$.subscribe(child => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = null;
            }
        });
    }
    onRemove(_previousOwner) {
        this._transform.parent = null;
    }
    /**
     * The z-index ordering of the entity, a higher values are drawn on top of lower values.
     * For example z=99 would be drawn on top of z=0.
     */
    get z() {
        return this._z;
    }
    set z(val) {
        const oldz = this._z;
        this._z = val;
        if (oldz !== val) {
            this.zIndexChanged$.notifyAll(val);
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(v) {
        this._transform.pos = v;
    }
    get globalPos() {
        return this._transform.globalPos;
    }
    set globalPos(v) {
        this._transform.globalPos = v;
    }
    get rotation() {
        return this._transform.rotation;
    }
    set rotation(rotation) {
        this._transform.rotation = rotation;
    }
    get globalRotation() {
        return this._transform.globalRotation;
    }
    set globalRotation(rotation) {
        this._transform.globalRotation = rotation;
    }
    get scale() {
        return this._transform.scale;
    }
    set scale(v) {
        this._transform.scale = v;
    }
    get globalScale() {
        return this._transform.globalScale;
    }
    set globalScale(v) {
        this._transform.globalScale = v;
    }
    applyInverse(v) {
        return this._transform.applyInverse(v);
    }
    apply(v) {
        return this._transform.apply(v);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts


class MotionComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.motion';
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inertia can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}

;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        return CollisionGroup.combine(collisionGroups).invert();
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);

;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Returns whether a it is allowed for 2 colliders in a Pair to collide
     * @param colliderA
     * @param colliderB
     */
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        // Prevent self collision
        if (colliderA.id === colliderB.id) {
            return false;
        }
        // Colliders with the same owner do not collide (composite colliders)
        if (colliderA.owner &&
            colliderB.owner &&
            colliderA.owner.id === colliderB.owner.id) {
            return false;
        }
        // if the pair has a member with zero dimension don't collide
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.active || !bodyB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}

;// CONCATENATED MODULE: ./Math/projection.ts
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts





/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= Physics.boundsPadding;
        b.top -= Physics.boundsPadding;
        b.right += Physics.boundsPadding;
        b.bottom += Physics.boundsPadding;
        // THIS IS CAUSING UNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.overlaps(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}

;// CONCATENATED MODULE: ./Math/ray.ts
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts









/**
 * Responsible for performing the collision broadphase (locating potential collisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor() {
        this._dynamicCollisionTree = new DynamicTree();
        this._pairs = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _pairExists(colliderA, colliderB) {
        // if the collision pair has been calculated already short circuit
        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
        return this._pairs.has(hash);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._pairs.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
                    const pair = new Pair(collider, other);
                    this._pairs.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (Physics.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.size * seconds + // velocity term
                    body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.globalPos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
                        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && Vector.isValid(minTranslate)) {
                        const pair = new Pair(collider, minCollider);
                        if (!this._pairs.has(pair.id)) {
                            this._pairs.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.globalPos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform.get());
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts


/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = createId('collider', Collider._ID++);
        /**
         * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider
         * @internal
         * @hidden
         */
        this.__compositeColliderId = null;
        this.events = new EventDispatcher();
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;

;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts








class CompositeCollider extends Collider {
    constructor(colliders) {
        super();
        this._collisionProcessor = new DynamicTreeCollisionProcessor();
        this._dynamicAABBTree = new DynamicTree();
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        this.events.wire(collider.events);
        collider.__compositeColliderId = this.id;
        this._colliders.push(collider);
        this._collisionProcessor.track(collider);
        this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
        this.events.unwire(collider.events);
        collider.__compositeColliderId = null;
        removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        // TODO transform component world pos
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
        return results;
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const points = [];
        for (const collider of colliders) {
            const vec = collider.rayCast(ray, max);
            if (vec) {
                points.push(vec);
            }
        }
        if (points.length) {
            let minPoint = points[0];
            let minDistance = minPoint.dot(ray.dir);
            for (const point of points) {
                const distance = ray.dir.dot(point);
                if (distance < minDistance) {
                    minPoint = point;
                    minDistance = distance;
                }
            }
            return minPoint;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projs = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projs.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projs.length) {
            const newProjection = new Projection(projs[0].min, projs[0].max);
            for (const proj of projs) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    debug(ex, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.debug(ex, color);
        }
    }
    clone() {
        return new CompositeCollider(this._colliders.map((c) => c.clone()));
    }
}

;// CONCATENATED MODULE: ./Math/line-segment.ts

/**
 * A 2D line segment
 */
class LineSegment {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        if (this._normal) {
            return this._normal;
        }
        return this._normal = this.end.sub(this.begin).normal();
    }
    dir() {
        if (this._dir) {
            return this._dir;
        }
        return this._dir = this.end.sub(this.begin);
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        if (this._slope) {
            return this._slope;
        }
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return this._slope = end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        if (this._length) {
            return this._length;
        }
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return this._length = distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new LineSegment(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
        let dir = sideVector;
        dir = dir.normalize();
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new LineSegment(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts



/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new LineSegment(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts










/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends Collider {
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = Vector.Zero;
        this._globalMatrix = AffineMatrix.identity();
        this.offset = options.offset || Vector.Zero;
        this.radius = options.radius || 0;
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    get worldPos() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Get the radius of the circle
     */
    get radius() {
        var _a;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        return this._naturalRadius * Math.min(scale.x, scale.y);
    }
    /**
     * Set the radius of the circle
     */
    set radius(val) {
        var _a;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        this._naturalRadius = val / Math.min(scale.x, scale.y);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        var _a, _b, _c;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);
        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius).rotate(rotation).scale(scale).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color) {
        var _a, _b, _c, _d;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);
        ex.save();
        ex.translate(pos.x, pos.y);
        ex.rotate(rotation);
        ex.scale(scale.x, scale.y);
        ex.drawCircle(((_d = this.offset) !== null && _d !== void 0 ? _d : Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);
        ex.restore();
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts




/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        var _a, _b;
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {
            // Add on the parent composite pair for start/end contact
            this.id += '|' + Pair.calculatePairHash((_a = colliderA.__compositeColliderId) !== null && _a !== void 0 ? _a : colliderA.id, (_b = colliderB.__compositeColliderId) !== null && _b !== void 0 ? _b : colliderB.id);
        }
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts








const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.size,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(TransformComponent).get());
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        var _a, _b, _c, _d;
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const incident = other.findSide(separation.axis.negate());
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const reference = separation.side;
        const refDir = reference.dir().normalize();
        // Find our contact points by clipping the incident by the collision side
        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
        }
        // If there is no left there is no collision
        if (clipLeft) {
            // We only want clip points below the reference edge, discard the others
            const points = clipLeft.getPoints().filter((p) => {
                return reference.below(p);
            });
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.center.sub(polyA.center).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            // Points are clipped from incident which is the other collider
            // Store those as locals
            let localPoints = [];
            if (separation.collider === polyA) {
                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            else {
                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
        // both are circles
        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||
            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||
            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||
            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts










/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this._globalMatrix = AffineMatrix.identity();
        this.begin = options.begin || Vector.Zero;
        this.end = options.end || Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const pos = begin.average(end);
        return pos;
    }
    _getTransformedBegin() {
        return this._globalMatrix.multiply(this.begin);
    }
    _getTransformedEnd() {
        return this._globalMatrix.multiply(this.end);
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new LineSegment(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts














/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends Collider {
    constructor(options) {
        var _a, _b;
        super();
        this._logger = Logger.getInstance();
        this._transformedPoints = [];
        this._sides = [];
        this._localSides = [];
        this._globalMatrix = AffineMatrix.identity();
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        this._localSidesDirty = true;
        this._localBoundsDirty = true;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
        this._globalMatrix.translate(this.offset.x, this.offset.y);
        this.points = (_b = options.points) !== null && _b !== void 0 ? _b : [];
        const counterClockwise = this._isCounterClockwiseWinding(this.points);
        if (!counterClockwise) {
            this.points.reverse();
        }
        if (!this.isConvex()) {
            this._logger.warn('Excalibur only supports convex polygon colliders and will not behave properly.' +
                'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');
        }
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    set points(points) {
        this._localBoundsDirty = true;
        this._localSidesDirty = true;
        this._sidesDirty = true;
        this._points = points;
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    get points() {
        return this._points;
    }
    _isCounterClockwiseWinding(points) {
        // https://stackoverflow.com/a/1165943
        let sum = 0;
        for (let i = 0; i < points.length; i++) {
            sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);
        }
        return sum < 0;
    }
    /**
     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
     * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape
     */
    isConvex() {
        // From SO: https://stackoverflow.com/a/45372025
        if (this.points.length < 3) {
            return false;
        }
        let oldPoint = this.points[this.points.length - 2];
        let newPoint = this.points[this.points.length - 1];
        let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
        let oldDirection = 0;
        let orientation = 0;
        let angleSum = 0;
        for (const [i, point] of this.points.entries()) {
            oldPoint = newPoint;
            oldDirection = direction;
            newPoint = point;
            direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
            if (oldPoint.equals(newPoint)) {
                return false; // repeat point
            }
            let angle = direction - oldDirection;
            if (angle <= -Math.PI) {
                angle += Math.PI * 2;
            }
            else if (angle > Math.PI) {
                angle -= Math.PI * 2;
            }
            if (i === 0) {
                if (angle === 0.0) {
                    return false;
                }
                orientation = angle > 0 ? 1 : -1;
            }
            else {
                if (orientation * angle <= 0) {
                    return false;
                }
            }
            angleSum += angle;
        }
        return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;
    }
    /**
     * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons
     */
    tessellate() {
        const polygons = [];
        for (let i = 1; i < this.points.length - 2; i++) {
            polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);
        }
        polygons.push([this.points[0], this.points[1], this.points[2]]);
        return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));
    }
    /**
     * Triangulate the polygon collider using the "Ear Clipping" algorithm.
     * Returns a new [[CompositeCollider]] made up of smaller triangles.
     */
    triangulate() {
        // https://www.youtube.com/watch?v=hTJFcHutls8
        if (this.points.length < 3) {
            throw Error('Invalid polygon');
        }
        /**
         * Helper to get a vertex in the list
         */
        function getItem(index, list) {
            if (index >= list.length) {
                return list[index % list.length];
            }
            else if (index < 0) {
                return list[index % list.length + list.length];
            }
            else {
                return list[index];
            }
        }
        /**
         * Quick test for point in triangle
         */
        function isPointInTriangle(point, a, b, c) {
            const ab = b.sub(a);
            const bc = c.sub(b);
            const ca = a.sub(c);
            const ap = point.sub(a);
            const bp = point.sub(b);
            const cp = point.sub(c);
            const cross1 = ab.cross(ap);
            const cross2 = bc.cross(bp);
            const cross3 = ca.cross(cp);
            if (cross1 > 0 || cross2 > 0 || cross3 > 0) {
                return false;
            }
            return true;
        }
        const triangles = [];
        const vertices = [...this.points];
        const indices = range(0, this.points.length - 1);
        // 1. Loop through vertices clockwise
        //    if the vertex is convex (interior angle is < 180) (cross product positive)
        //    if the polygon formed by it's edges doesn't contain the points
        //         it's an ear add it to our list of triangles, and restart
        while (indices.length > 3) {
            for (let i = 0; i < indices.length; i++) {
                const a = indices[i];
                const b = getItem(i - 1, indices);
                const c = getItem(i + 1, indices);
                const va = vertices[a];
                const vb = vertices[b];
                const vc = vertices[c];
                // Check convexity
                const leftArm = vb.sub(va);
                const rightArm = vc.sub(va);
                const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex
                if (!isConvex) {
                    continue;
                }
                let isEar = true;
                // Check that if any vertices are in the triangle a, b, c
                for (let j = 0; j < indices.length; j++) {
                    const vertIndex = indices[j];
                    // We can skip these
                    if (vertIndex === a || vertIndex === b || vertIndex === c) {
                        continue;
                    }
                    const point = vertices[vertIndex];
                    if (isPointInTriangle(point, vb, va, vc)) {
                        isEar = false;
                        break;
                    }
                }
                // Add ear to polygon list and remove from list
                if (isEar) {
                    triangles.push([vb, va, vc]);
                    indices.splice(i, 1);
                    break;
                }
            }
        }
        triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);
        return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        if (this._transform) {
            return this._transform.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const points = this.points;
        const len = points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        if (this._transformedPointsDirty) {
            this._calculateTransformation();
            this._transformedPointsDirty = false;
        }
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sidesDirty) {
            const lines = [];
            const points = this.getTransformedPoints();
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new LineSegment(points[i], points[(i + 1) % len]));
            }
            this._sides = lines;
            this._sidesDirty = false;
        }
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSidesDirty) {
            const lines = [];
            const points = this.points;
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new LineSegment(points[i], points[(i + 1) % len]));
            }
            this._localSides = lines;
            this._localSidesDirty = false;
        }
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        const axes = [];
        const sides = this.getSides();
        for (let i = 0; i < sides.length; i++) {
            axes.push(sides[i].normal());
        }
        return axes;
    }
    /**
     * Updates the transform for the collision geometry
     *
     * Collision geometry (points/bounds) will not change until this is called.
     * @param transform
     */
    update(transform) {
        var _a;
        this._transform = transform;
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        // This change means an update must be performed in order for geometry to update
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new Ray(point, new Vector(1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof CircleCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        return this.localBounds.transform(this._globalMatrix);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        if (this._localBoundsDirty) {
            this._localBounds = BoundingBox.fromPoints(this.points);
            this._localBoundsDirty = false;
        }
        return this._localBounds;
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        if (this._cachedMass === mass && this._cachedInertia) {
            return this._cachedInertia;
        }
        let numerator = 0;
        let denominator = 0;
        const points = this.points;
        for (let i = 0; i < points.length; i++) {
            const iplusone = (i + 1) % points.length;
            const crossTerm = points[iplusone].cross(points[i]);
            numerator +=
                crossTerm *
                    (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));
            denominator += crossTerm;
        }
        this._cachedMass = mass;
        return this._cachedInertia = (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new Projection(min, max);
    }
    debug(ex, color) {
        const firstPoint = this.getTransformedPoints()[0];
        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
        for (let i = 0; i < points.length - 1; i++) {
            ex.drawLine(points[i], points[i + 1], color, 2);
            ex.drawCircle(points[i], 2, color);
            ex.drawCircle(points[i + 1], 2, color);
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
        return new PolygonCollider({
            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, offset = Vector.Zero) {
        return new PolygonCollider({
            points: points,
            offset: offset
        });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
        return new CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
        const logger = Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, Vector.Half, offset),
                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, Vector.Half, offset),
                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts









class ColliderComponent extends Component {
    constructor(collider) {
        super();
        this.type = 'ex.collider';
        this.events = new EventDispatcher();
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new Observable();
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            this.events.wire(collider.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this.events.unwire(this._collider.events);
            this.$colliderRemoved.notifyAll(this._collider);
            this._collider.owner = null;
            this._collider = null;
        }
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx.get());
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite lefthand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
        const collider = Shape.Box(width, height, anchor, center);
        return (this.set(collider));
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
        const poly = Shape.Polygon(points, center);
        return (this.set(poly));
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
        const collider = Shape.Circle(radius, center);
        return (this.set(collider));
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = Shape.Edge(begin, end);
        return (this.set(collider));
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     */
    useCompositeCollider(colliders) {
        return (this.set(new CompositeCollider(colliders)));
    }
}

;// CONCATENATED MODULE: ./Collision/BodyComponent.ts












var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.type = 'ex.body';
        this.dependencies = [TransformComponent, MotionComponent];
        this.id = createId('body', BodyComponent._ID++);
        this.events = new EventDispatcher();
        this._oldTransform = new Transform();
        /**
         * Indicates whether the old transform has been captured at least once for interpolation
         * @internal
         */
        this.__oldTransformCaptured = false;
        /**
         * Enable or disabled the fixed update interpolation, by default interpolation is on.
         */
        this.enableFixedUpdateInterpolate = true;
        /**
         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]
         */
        this.collisionType = CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = CollisionGroup.All;
        /**
         * The amount of mass the body has
         */
        this._mass = Physics.defaultMass;
        /**
         * Amount of "motion" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to "sleep"
         */
        this.sleepMotion = Physics.sleepEpsilon * 5;
        /**
         * Can this body sleep, by default bodies do not sleep
         */
        this.canSleep = Physics.bodiesCanSleepByDefault;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         *
         * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond
         */
        this.limitDegreeOfFreedom = [];
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = Vector.Zero;
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
        }
    }
    get matrix() {
        return this.transform.get().matrix;
    }
    get mass() {
        return this._mass;
    }
    set mass(newMass) {
        this._mass = newMass;
        this._cachedInertia = undefined;
        this._cachedInverseInertia = undefined;
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = Physics.sleepEpsilon * 5;
        }
        else {
            this.vel = Vector.Zero;
            this.acc = Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.setSleeping(true);
        }
        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = Physics.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
            this.setSleeping(true);
        }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
        if (this._cachedInertia) {
            return this._cachedInertia;
        }
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(ColliderComponent);
        if (collider) {
            collider.$colliderAdded.subscribe(() => {
                this._cachedInertia = null;
            });
            collider.$colliderRemoved.subscribe(() => {
                this._cachedInertia = null;
            });
            const maybeCollider = collider.get();
            if (maybeCollider) {
                return this._cachedInertia = maybeCollider.getInertia(this.mass);
            }
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        if (this._cachedInverseInertia) {
            return this._cachedInverseInertia;
        }
        return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    /**
     * @deprecated Use globalP0s
     */
    get center() {
        return this.globalPos;
    }
    get transform() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    get pos() {
        return this.transform.pos;
    }
    set pos(val) {
        this.transform.pos = val;
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get globalPos() {
        return this.transform.globalPos;
    }
    set globalPos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The position of the actor last frame (x, y) in pixels
     */
    get oldPos() {
        return this._oldTransform.pos;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * Gets/sets the rotation of the body from the last frame.
     */
    get oldRotation() {
        return this._oldTransform.rotation;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The scale of the actor last frame
     */
    get oldScale() {
        return this._oldTransform.scale;
    }
    /**
     * The scale rate of change of the actor in scale/second
     */
    get scaleFactor() {
        return this.motion.scaleFactor;
    }
    set scaleFactor(scaleFactor) {
        this.motion.scaleFactor = scaleFactor;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impulse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.__oldTransformCaptured = true;
        this.transform.get().clone(this._oldTransform);
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
    }
}
BodyComponent._ID = 0;

;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts





/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends Class {
    constructor(components, name) {
        super();
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this._name = 'anonymous';
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        this._componentTypeToInstance = new Map();
        this._componentStringToInstance = new Map();
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.componentAdded$ = new Observable();
        this.componentRemoved$ = new Observable();
        this._parent = null;
        this.childrenAdded$ = new Observable();
        this.childrenRemoved$ = new Observable();
        this._children = [];
        this._isInitialized = false;
        this._setName(name);
        if (components) {
            for (const component of components) {
                this.addComponent(component);
            }
        }
    }
    _setName(name) {
        if (name) {
            this._name = name;
        }
    }
    get name() {
        return this._name;
    }
    get events() {
        return this.eventDispatcher;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
        return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
        return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Array.from(this._componentStringToInstance.values())
            .filter((c) => c instanceof TagComponent)
            .map((c) => c.type);
        this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
        return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
        this._rebuildMemos();
        const added = new AddedComponent({
            component,
            entity: this
        });
        this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
        const removed = new RemovedComponent({
            component,
            entity: this
        });
        this.componentRemoved$.notifyAll(removed);
        this._rebuildMemos();
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            removeItemFromArray(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        this.children.forEach((c) => {
            this.removeChild(c);
        });
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            queue = queue.concat(curr.children);
            result = result.concat(curr.children);
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.get(c).clone());
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it already exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.type)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component);
            }
            else {
                // early exit component exits
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const constuctorType = component.constructor;
        this._componentTypeToInstance.set(constuctorType, component);
        this._componentStringToInstance.set(component.type, component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this._notifyAddComponent(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof Component) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.has(type)) {
            const component = this.get(type);
            component.owner = null;
            if (component.onRemove) {
                component.onRemove(this);
            }
            const ctor = component.constructor;
            this._componentTypeToInstance.delete(ctor);
            this._componentStringToInstance.delete(component.type);
            this._notifyRemoveComponent(component);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    has(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.has(type);
        }
        else {
            return this._componentTypeToInstance.has(type);
        }
    }
    get(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.get(type);
        }
        else {
            return this._componentTypeToInstance.get(type);
        }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        for (const child of this.children) {
            child.update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
}
Entity._ID = 0;

;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts





/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
class GraphicsLayer {
    constructor(_options, _graphics) {
        this._options = _options;
        this._graphics = _graphics;
        this.graphics = [];
    }
    get name() {
        return this._options.name;
    }
    hide(nameOrGraphic) {
        if (!nameOrGraphic) {
            this.graphics.length = 0;
        }
        else {
            let gfx = null;
            if (nameOrGraphic instanceof Graphic) {
                gfx = nameOrGraphic;
            }
            else {
                gfx = this._graphics.getGraphic(nameOrGraphic);
            }
            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);
            this._graphics.recalculateBounds();
        }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
        options = { ...options };
        let gfx;
        if (nameOrGraphic instanceof Graphic) {
            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
        }
        else {
            gfx = this._graphics.getGraphic(nameOrGraphic);
            if (!gfx) {
                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
            }
        }
        if (gfx) {
            this.graphics.push({ graphic: gfx, options });
            this._graphics.recalculateBounds();
            return gfx;
        }
        else {
            return null;
        }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        options = { ...options };
        this.hide();
        return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
        return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
        this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
        var _a;
        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
        this._options.offset = value;
    }
    get currentKeys() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';
    }
}
class GraphicsLayers {
    constructor(_component) {
        this._component = _component;
        this._layers = [];
        this._layerMap = {};
        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);
        this._maybeAddLayer(this.default);
    }
    create(options) {
        const layer = new GraphicsLayer(options, this._component);
        return this._maybeAddLayer(layer);
    }
    get(name) {
        if (name) {
            return this._getLayer(name);
        }
        return this._layers;
    }
    currentKeys() {
        const graphicsLayerKeys = [];
        for (const layer of this._layers) {
            graphicsLayerKeys.push(layer.currentKeys);
        }
        return graphicsLayerKeys;
    }
    has(name) {
        return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
        if (this._layerMap[layer.name]) {
            // todo log warning
            return this._layerMap[layer.name];
        }
        this._layerMap[layer.name] = layer;
        this._layers.push(layer);
        this._layers.sort((a, b) => a.order - b.order);
        return layer;
    }
    _getLayer(name) {
        return this._layerMap[name];
    }
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends Component {
    constructor(options) {
        super();
        this.type = 'ex.graphics';
        this._graphics = {};
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        /**
         * Offset to apply to graphics by default
         */
        this.offset = Vector.Zero;
        /**
         * Anchor to apply to graphics by default
         */
        this.anchor = Vector.Half;
        /**
         * If set to true graphics added to the component will be copied. This can affect performance
         */
        this.copyGraphics = false;
        this._localBounds = null;
        // Defaults
        options = {
            visible: this.visible,
            ...options
        };
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
        this._graphics = graphics || {};
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.visible = !!visible;
        this.layers = new GraphicsLayers(this);
        if (current && this._graphics[current]) {
            this.show(this._graphics[current]);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
        return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    add(nameOrGraphic, graphic) {
        let name = 'default';
        let graphicToSet = null;
        if (typeof nameOrGraphic === 'string') {
            name = nameOrGraphic;
            graphicToSet = graphic;
        }
        else {
            graphicToSet = nameOrGraphic;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        if (name === 'default') {
            this.show('default');
        }
        return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
        const result = this.layers.default.show(nameOrGraphic, options);
        this.recalculateBounds();
        return result;
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        const result = this.layers.default.use(nameOrGraphic, options);
        this.recalculateBounds();
        return result;
    }
    hide(nameOrGraphic) {
        this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
        this._localBounds = bounds;
    }
    recalculateBounds() {
        let bb = new BoundingBox();
        for (const layer of this.layers.get()) {
            for (const { graphic, options } of layer.graphics) {
                let anchor = this.anchor;
                let offset = this.offset;
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const bounds = graphic.localBounds;
                const offsetX = -bounds.width * anchor.x + offset.x;
                const offsetY = -bounds.height * anchor.y + offset.y;
                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);
            }
        }
        this._localBounds = bb;
    }
    get localBounds() {
        if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
            this.recalculateBounds();
        }
        return this._localBounds;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        for (const layer of this.layers.get()) {
            for (const { graphic } of layer.graphics) {
                if (hasGraphicsTick(graphic)) {
                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Rectangle.ts

/**
 * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]
 */
class Rectangle extends Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle({
            width: this.width,
            height: this.height,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Circle.ts


/**
 * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]
 *
 * Circles default to [[ImageFiltering.Blended]]
 */
class Circle extends Raster {
    constructor(options) {
        var _a, _b;
        super(options);
        this._radius = 0;
        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.filtering = (_b = options.filtering) !== null && _b !== void 0 ? _b : ImageFiltering.Blended;
        this.rasterize();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    clone() {
        return new Circle({
            radius: this.radius,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Input/PointerComponent.ts

/**
 * Add this component to optionally configure how the pointer
 * system detects pointer events.
 *
 * By default the collider shape is used and graphics bounds is not.
 *
 * If both collider shape and graphics bounds are enabled it will fire events if either or
 * are intersecting the pointer.
 */
class PointerComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.pointer';
        /**
         * Use any existing Collider component geometry for pointer events. This is useful if you want
         * user pointer events only to trigger on the same collision geometry used in the collider component
         * for collision resolution. Default is `true`.
         */
        this.useColliderShape = true;
        /**
         * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned
         * bounds around the graphic to trigger pointer events. Default is `false`.
         */
        this.useGraphicsBounds = false;
    }
}

;// CONCATENATED MODULE: ./Util/EasingFunctions.ts

/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});

;// CONCATENATED MODULE: ./Actions/ActionQueue.ts
/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(elapsedMs);
            if (this._currentAction.isComplete(this._entity)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts

class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(delta) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts

/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts




class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = new Vector(offsetX, offsetY);
        if (speed <= 0) {
            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts



class MoveTo {
    constructor(entity, destx, desty, speed) {
        this.entity = entity;
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = new Vector(destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/RotationType.ts
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));

;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts




class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts




class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._start = undefined;
        this._currentNonCannonAngle = undefined;
        this._distance = undefined;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts



class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = vec(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.y - this._startX) >= (this._distanceX - 0.01) &&
                Math.abs(this._tx.scale.y - this._startY) >= (this._distanceY - 0.01)));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts



class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._offset = new Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= (this._distanceX - 0.01) &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= (this._distanceY - 0.01)));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts
class CallMethod {
    constructor(method) {
        this._method = null;
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(_delta) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts



class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseBy.ts



class EaseBy {
    constructor(entity, offsetX, offsetY, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._offset = new Vector(offsetX, offsetY);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._lerpEnd = this._lerpStart.add(this._offset);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Blink.ts

class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
            this._elapsedTime = 0;
            this._totalTime = 0;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
            this._graphics.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.visible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Fade.ts


class Fade {
    constructor(entity, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(GraphicsComponent);
        this._endOpacity = endOpacity;
        this._speed = this._ogspeed = speed;
    }
    update(delta) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            this._speed = this._ogspeed;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._graphics.opacity += (this._multiplier *
                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Delay.ts
class Delay {
    constructor(delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Die.ts

class Die {
    constructor(entity) {
        this._stopped = false;
        this._entity = entity;
    }
    update(_delta) {
        this._entity.get(ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Follow.ts



class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._followTx = entityToFollow.get(TransformComponent);
        this._followMotion = entityToFollow.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = vec(m.x, m.y);
        }
        else {
            this._motion.vel = vec(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Meet.ts



class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(TransformComponent);
        this._motion = actor.get(MotionComponent);
        this._meetTx = actorToMeet.get(TransformComponent);
        this._meetMotion = actorToMeet.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._distanceBetween = undefined;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionContext.ts




















/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsedMs) {
        this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    runAction(action) {
        action.reset();
        this._queue.add(action);
        return this;
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    easeBy(...args) {
        var _a, _b;
        let offsetX = 0;
        let offsetY = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            offsetX = args[0].x;
            offsetY = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            offsetX = args[0];
            offsetY = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));
        return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPos instanceof Vector) {
            x = xOrPos.x;
            y = xOrPos.y;
            speed = yOrSpeed;
        }
        else {
            x = xOrPos;
            y = yOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveTo(this._entity, x, y, speed));
        return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVector instanceof Vector) {
            xOffset = xOffsetOrVector.x;
            yOffset = xOffsetOrVector.y;
            speed = yOffsetOrSpeed;
        }
        else {
            xOffset = xOffsetOrVector;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
        return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
            sizeX = sizeXOrVector.x;
            sizeY = sizeXOrVector.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVector;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVector instanceof Vector) {
            sizeOffsetX = sizeOffsetXOrVector.x;
            sizeOffsetY = sizeOffsetXOrVector.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVector;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        this._queue.add(new Fade(this._entity, opacity, time));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        this._queue.add(new Delay(time));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new Follow(this._entity, entity));
        }
        else {
            this._queue.add(new Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new Meet(this._entity, entity));
        }
        else {
            this._queue.add(new Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts




;
class ActionsComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.actions';
        this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
        this._ctx = new ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queue
     */
    getQueue() {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    runAction(action) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.runAction(action);
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
        return this._ctx.easeTo.apply(this._ctx, args);
    }
    easeBy(...args) {
        return this._ctx.easeBy.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._ctx.toPromise();
    }
}

;// CONCATENATED MODULE: ./Graphics/FontCommon.ts
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
/**
 * Enum representing the text direction, useful for other languages, or writing text in reverse
 */
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./Graphics/Font.ts







/**
 * Represents a system or web font in Excalibur
 *
 * If no options specified, the system sans-serif 10 pixel is used
 *
 * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/
 */
class Font extends Graphic {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        super(options); // <- Graphics properties
        /**
         * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing
         *
         * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]
         */
        this.filtering = ImageFiltering.Blended;
        /**
         * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 2)
         */
        this.quality = 2;
        // Raster properties for fonts
        this.padding = 2;
        this.smoothing = false;
        this.lineWidth = 1;
        this.lineDash = [];
        this.color = Color.Black;
        this.family = 'sans-serif';
        this.style = FontStyle.Normal;
        this.bold = false;
        this.unit = FontUnit.Px;
        this.textAlign = TextAlign.Left;
        this.baseAlign = BaseAlign.Alphabetic;
        this.direction = Direction.LeftToRight;
        this.size = 10;
        this.shadow = null;
        this._textBounds = new BoundingBox();
        this._cachedTextMeasurement = new Map();
        this._bitmapToTextMeasurement = new Map();
        this._textToBitmap = new Map();
        this._bitmapUsage = new Map();
        this._textFragments = [];
        // Raster properties
        this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;
        this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;
        this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;
        this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;
        this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
        this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;
        this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;
        // Font specific properties
        this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;
        this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;
        this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;
        this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;
        this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;
        this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;
        this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;
        this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;
        this.quality = (_r = options === null || options === void 0 ? void 0 : options.quality) !== null && _r !== void 0 ? _r : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_s = options.shadow.blur) !== null && _s !== void 0 ? _s : this.shadow.blur;
            this.shadow.offset = (_t = options.shadow.offset) !== null && _t !== void 0 ? _t : this.shadow.offset;
            this.shadow.color = (_u = options.shadow.color) !== null && _u !== void 0 ? _u : this.shadow.color;
        }
    }
    clone() {
        return new Font({
            ...this.cloneGraphicOptions(),
            size: this.size,
            unit: this.unit,
            family: this.family,
            style: this.style,
            bold: this.bold,
            textAlign: this.textAlign,
            baseAlign: this.baseAlign,
            direction: this.direction,
            shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : null
        });
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(_ex, _x, _y) {
        // TODO weird vestigial drawimage
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Returns a BoundingBox that is the total size of the text including multiple lines
     *
     * Does not include any padding or adjustment
     * @param text
     * @returns BoundingBox
     */
    measureText(text) {
        let measurementDirty = false;
        let cached = this._cachedTextMeasurement.get(text);
        if (!cached) {
            measurementDirty = true;
        }
        const rasterProps = this._getRasterPropertiesHash();
        if (!cached || rasterProps !== cached.rasterProps) {
            measurementDirty = true;
        }
        if (measurementDirty) {
            const lines = text.split('\n');
            const maxWidthLine = lines.reduce((a, b) => {
                return a.length > b.length ? a : b;
            });
            const ctx = this._getTextBitmap(text);
            this._applyFont(ctx); // font must be applied to the context to measure it
            const metrics = ctx.measureText(maxWidthLine);
            let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
            // TODO lineheight makes the text bounds wonky
            const lineAdjustedHeight = textHeight * lines.length;
            textHeight = lineAdjustedHeight;
            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
            const x = 0;
            const y = 0;
            // this._cachedText = text;
            // this._cachedRasterProps = rasterProps;
            // this._measurementDirty = false;
            const measurement = new BoundingBox({
                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,
                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,
                bottom: y + bottomBounds + this.padding,
                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding
            });
            cached = {
                text,
                rasterProps,
                measurement
            };
            this._cachedTextMeasurement.set(text, cached);
            this._bitmapToTextMeasurement.set(ctx, cached);
            return cached.measurement;
        }
        else {
            return cached.measurement;
        }
    }
    _setDimension(textBounds, bitmap) {
        // Changing the width and height clears the context properties
        // We double the bitmap width to account for all possible alignment
        // We scale by "quality" so we render text without jaggies
        bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;
        bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;
    }
    _postDraw(ex) {
        ex.restore();
    }
    /**
     * We need to identify bitmaps with more than just the text content
     *
     * Any properties that can change the rendering of the text
     */
    _getRasterPropertiesHash(color) {
        var _a, _b;
        const hash = '__hashcode__' +
            this.fontString +
            this.showDebug +
            this.textAlign +
            this.baseAlign +
            this.direction +
            JSON.stringify(this.shadow) +
            (this.padding.toString() +
                this.smoothing.toString() +
                this.lineWidth.toString() +
                this.lineDash.toString() +
                ((_a = this.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) +
                (color ? color.toString() : (_b = this.color) === null || _b === void 0 ? void 0 : _b.toString()).toString());
        return hash;
    }
    _applyRasterProperties(ctx, color) {
        var _a, _b, _c;
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = color ? color.toString() : (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _applyFont(ctx) {
        ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);
        ctx.scale(this.quality, this.quality);
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.baseAlign;
        ctx.font = this.fontString;
        ctx.direction = this.direction;
        if (this.shadow) {
            ctx.shadowColor = this.shadow.color.toString();
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offset.x;
            ctx.shadowOffsetY = this.shadow.offset.y;
        }
    }
    _drawText(ctx, text, colorOverride, lineHeight) {
        const lines = text.split('\n');
        this._applyRasterProperties(ctx, colorOverride);
        this._applyFont(ctx);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (this.color) {
                ctx.fillText(line, 0, i * lineHeight);
            }
            if (this.strokeColor) {
                ctx.strokeText(line, 0, i * lineHeight);
            }
        }
        if (this.showDebug) {
            // Horizontal line
            /* istanbul ignore next */
            line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);
            // Vertical line
            /* istanbul ignore next */
            line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);
        }
    }
    _getTextBitmap(text, color) {
        const textAndHash = text + this._getRasterPropertiesHash(color);
        const bitmap = this._textToBitmap.get(textAndHash);
        if (bitmap) {
            return bitmap;
        }
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        this._textToBitmap.set(textAndHash, ctx);
        return ctx;
    }
    _splitTextBitmap(bitmap) {
        const textImages = [];
        let currentX = 0;
        let currentY = 0;
        // 4k is the max for mobile devices
        const width = Math.min(4096, bitmap.canvas.width);
        const height = Math.min(4096, bitmap.canvas.height);
        // Splits the original bitmap into 4k max chunks
        while (currentX < bitmap.canvas.width) {
            while (currentY < bitmap.canvas.height) {
                // create new bitmap
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                // draw current slice to new bitmap in < 4k chunks
                ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);
                textImages.push({ x: currentX, y: currentY, canvas });
                currentY += height;
            }
            currentX += width;
            currentY = 0;
        }
        return textImages;
    }
    render(ex, text, colorOverride, x, y) {
        if (this.showDebug) {
            this.clearCache();
        }
        this.checkAndClearCache();
        // Get bitmap for rastering text, this is cached by raster properties
        const bitmap = this._getTextBitmap(text, colorOverride);
        const isNewBitmap = !this._bitmapUsage.get(bitmap);
        // Bounds of the text
        this._textBounds = this.measureText(text);
        if (isNewBitmap) {
            // Setting dimension is expensive because it invalidates the bitmap
            this._setDimension(this._textBounds, bitmap);
        }
        // Apply affine transformations
        this._preDraw(ex, x, y);
        const lines = text.split('\n');
        const lineHeight = this._textBounds.height / lines.length;
        if (isNewBitmap) {
            // draws the text to the bitmap
            this._drawText(bitmap, text, colorOverride, lineHeight);
            // clean up any existing fragments
            for (const frag of this._textFragments) {
                TextureLoader["delete"](frag.canvas);
            }
            this._textFragments = this._splitTextBitmap(bitmap);
            for (const frag of this._textFragments) {
                TextureLoader.load(frag.canvas, this.filtering, true);
            }
        }
        // draws the bitmap fragments to excalibur graphics context
        for (const frag of this._textFragments) {
            ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2, frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2, frag.canvas.width / this.quality, frag.canvas.height / this.quality);
        }
        this._postDraw(ex);
        // Cache the bitmap for certain amount of time
        this._bitmapUsage.set(bitmap, performance.now());
    }
    /**
     * Get the internal cache size of the font
     * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps
     */
    get cacheSize() {
        return this._bitmapUsage.size;
    }
    /**
     * Force clear all cached text bitmaps
     */
    clearCache() {
        this._bitmapUsage.clear();
    }
    /**
     * Remove any expired cached text bitmaps
     */
    checkAndClearCache() {
        for (const [bitmap, time] of this._bitmapUsage.entries()) {
            // if bitmap hasn't been used in 1 second clear it
            if (time + 1000 < performance.now()) {
                this._bitmapUsage.delete(bitmap);
                // Cleanup measurements
                const measurement = this._bitmapToTextMeasurement.get(bitmap);
                if (measurement) {
                    this._cachedTextMeasurement.delete(measurement.text);
                    this._bitmapToTextMeasurement.delete(bitmap);
                }
                TextureLoader["delete"](bitmap.canvas);
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Text.ts



/**
 * Represent Text graphics in excalibur
 *
 * Useful for in game labels, ui, or overlays
 */
class Text extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        this._textWidth = 0;
        this._textHeight = 0;
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
    }
    clone() {
        var _a, _b;
        return new Text({
            text: this.text.slice(),
            color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : Color.Black,
            font: this.font.clone()
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        const bounds = this.font.measureText(this._text);
        this._textWidth = bounds.width;
        this._textHeight = bounds.height;
    }
    get font() {
        return this._font;
    }
    set font(font) {
        this._font = font;
    }
    get width() {
        if (this._textWidth === 0) {
            this._calculateDimension();
        }
        return this._textWidth * this.scale.x;
    }
    get height() {
        if (this._textHeight === 0) {
            this._calculateDimension();
        }
        return this._textHeight * this.scale.y;
    }
    _calculateDimension() {
        const { width, height } = this.font.measureText(this._text);
        this._textWidth = width;
        this._textHeight = height;
    }
    get localBounds() {
        return this.font.measureText(this._text).scale(this.scale);
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _drawImage(ex, x, y) {
        var _a;
        let color = Color.Black;
        if (this.font instanceof Font) {
            color = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;
        }
        if (this.isStale() || this.font.isStale()) {
            this.font.flipHorizontal = this.flipHorizontal;
            this.font.flipVertical = this.flipVertical;
            this.font.rotation = this.rotation;
            this.font.origin = this.origin;
            this.font.opacity = this.opacity;
        }
        this.font.tint = this.tint;
        const { width, height } = this.font.measureText(this._text);
        this._textWidth = width;
        this._textHeight = height;
        this.font.render(ex, this._text, color, x, y);
        if (this.font.showDebug) {
            ex.debug.drawRect(x - width, y - height, width * 2, height * 2);
        }
    }
}

;// CONCATENATED MODULE: ./Actor.ts



















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Entity {
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        /**
         * The anchor to apply all actor related transformations like rotation,
         * translation, and scaling. By default the anchor is in the center of
         * the actor. By default it is set to the center of the actor (.5, .5)
         *
         * An anchor of (.5, .5) will ensure that drawings are centered.
         *
         * Use `anchor.setTo` to set the anchor to a different point using
         * values between 0 and 1. For example, anchoring to the top-left would be
         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
         */
        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = Logger.getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        const { name, x, y, pos, coordPlane, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = {
            ...config
        };
        this._setName(name);
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        const tx = new TransformComponent();
        this.addComponent(tx);
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        tx.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : CoordPlane.World;
        this.addComponent(new PointerComponent);
        this.addComponent(new GraphicsComponent({
            anchor: this.anchor
        }));
        this.addComponent(new MotionComponent());
        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.addComponent(new ActionsComponent());
        this.addComponent(new BodyComponent());
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (collider) {
            this.addComponent(new ColliderComponent(collider));
        }
        else if (radius) {
            this.addComponent(new ColliderComponent(Shape.Circle(radius)));
        }
        else {
            if (width > 0 && height > 0) {
                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
            }
            else {
                this.addComponent(new ColliderComponent()); // no collider
            }
        }
        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
        if (color) {
            this.color = color;
            if (width && height) {
                this.graphics.add(new Rectangle({
                    color: color,
                    width,
                    height
                }));
            }
            else if (radius) {
                this.graphics.add(new Circle({
                    color: color,
                    radius
                }));
            }
        }
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
        return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
        return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
        return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
        return this.get(ColliderComponent);
    }
    /**
     * Access to the Actor's built in [[PointerComponent]] config
     */
    get pointer() {
        return this.get(PointerComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
        return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(TransformComponent).scale;
    }
    set scale(scale) {
        this.get(TransformComponent).scale = scale;
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('ex.offscreen');
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor's current graphic
     */
    get color() {
        return this._color;
    }
    set color(v) {
        var _a;
        this._color = v.clone();
        const defaultLayer = this.graphics.layers.default;
        const currentGraphic = (_a = defaultLayer.graphics[0]) === null || _a === void 0 ? void 0 : _a.graphic;
        if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {
            currentGraphic.color = this._color;
        }
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new PreKillEvent(this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new PostKillEvent(this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.active;
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(TransformComponent).z = newZ;
    }
    /**
     * Get the center point of an actor (global position)
     */
    get center() {
        const globalPos = this.getGlobalPos();
        return new Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);
    }
    /**
     * Get the local center point of an actor
     */
    get localCenter() {
        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
        return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
        return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = vec(x, y);
        const collider = this.get(ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(ColliderComponent);
        const otherCollider = actor.get(ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: Vector.Half
};

;// CONCATENATED MODULE: ./ScreenElement.ts





/**
 * Type guard to detect a screen element
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement;
}
/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement extends Actor {
    constructor(config) {
        super({ ...config });
        this.get(TransformComponent).coordPlane = CoordPlane.Screen;
        this.anchor = vec(0, 0);
        this.body.collisionType = CollisionType.PreventCollision;
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}

;// CONCATENATED MODULE: ./Timer.ts


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats, randomRange, random) {
        this._logger = Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this.randomRange = [0, 0];
        this._baseInterval = 10;
        this._generateRandomInterval = () => {
            return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);
        };
        this._complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
            randomRange = options.randomRange;
            random = options.random;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this._callbacks = [];
        this._baseInterval = this.interval = interval;
        if (!!randomRange) {
            if (randomRange[0] > randomRange[1]) {
                throw new Error('min value must be lower than max value for range');
            }
            //We use the instance of ex.Random to generate the range
            this.random = random !== null && random !== void 0 ? random : new Random();
            this.randomRange = randomRange;
            this.interval = this._generateRandomInterval();
            this.on(() => {
                this.interval = this._generateRandomInterval();
            });
        }
        ;
        this.repeats = repeats || this.repeats;
        if (fcn) {
            this.on(fcn);
        }
    }
    get complete() {
        return this._complete;
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (this._running) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this._baseInterval = this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;

;// CONCATENATED MODULE: ./Graphics/ParallaxComponent.ts


class ParallaxComponent extends Component {
    constructor(parallaxFactor) {
        super();
        this.type = 'ex.parallax';
        this.parallaxFactor = vec(1.0, 1.0);
        this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;
    }
}

;// CONCATENATED MODULE: ./Graphics/DebugGraphicsComponent.ts

/**
 * Provide arbitrary drawing for the purposes of debugging your game
 *
 * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]
 *
 */
class DebugGraphicsComponent extends Component {
    constructor(draw, useTransform = true) {
        super();
        this.draw = draw;
        this.useTransform = useTransform;
        this.type = 'ex.debuggraphics';
    }
}

;// CONCATENATED MODULE: ./TileMap/TileMap.ts















/**
 * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.
 *
 * TileMaps are useful for top down or side scrolling grid oriented games.
 */
class TileMap extends Entity {
    /**
     * @param options
     */
    constructor(options) {
        var _a, _b;
        super(null, options.name);
        this._token = 0;
        this._onScreenXStart = 0;
        this._onScreenXEnd = Number.MAX_VALUE;
        this._onScreenYStart = 0;
        this._onScreenYEnd = Number.MAX_VALUE;
        this.logger = Logger.getInstance();
        this.tiles = [];
        this._rows = [];
        this._cols = [];
        this.renderFromTopOfGraphic = false;
        this._collidersDirty = true;
        this._originalOffsets = new WeakMap();
        this.addComponent(new TransformComponent());
        this.addComponent(new MotionComponent());
        this.addComponent(new BodyComponent({
            type: CollisionType.Fixed
        }));
        this.addComponent(new GraphicsComponent({
            onPostDraw: (ctx, delta) => this.draw(ctx, delta)
        }));
        this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));
        this.addComponent(new ColliderComponent());
        this._graphics = this.get(GraphicsComponent);
        this._transform = this.get(TransformComponent);
        this._motion = this.get(MotionComponent);
        this._collider = this.get(ColliderComponent);
        this._composite = this._collider.useCompositeCollider([]);
        this._transform.pos = (_a = options.pos) !== null && _a !== void 0 ? _a : Vector.Zero;
        this._oldPos = this._transform.pos;
        this.renderFromTopOfGraphic = (_b = options.renderFromTopOfGraphic) !== null && _b !== void 0 ? _b : this.renderFromTopOfGraphic;
        this.tileWidth = options.tileWidth;
        this.tileHeight = options.tileHeight;
        this.rows = options.rows;
        this.columns = options.columns;
        this.tiles = new Array(this.rows * this.columns);
        this._rows = new Array(this.rows);
        this._cols = new Array(this.columns);
        let currentCol = [];
        for (let i = 0; i < this.columns; i++) {
            for (let j = 0; j < this.rows; j++) {
                const cd = new Tile({
                    x: i,
                    y: j,
                    map: this
                });
                cd.map = this;
                this.tiles[i + j * this.columns] = cd;
                currentCol.push(cd);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(cd);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this._graphics.localBounds = new BoundingBox({
            left: 0,
            top: 0,
            right: this.columns * this.tileWidth,
            bottom: this.rows * this.tileHeight
        });
    }
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    get x() {
        var _a;
        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(TransformComponent).pos = vec(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this._transform.pos = vec(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this._transform) {
            this._transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
            this._transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this._transform.scale = val;
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(val) {
        this._transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _getOrSetColliderOriginalOffset(collider) {
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return this._originalOffsets.get(collider);
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this._composite.clearColliders();
        const colliders = [];
        this._composite = this._collider.useCompositeCollider([]);
        let current;
        // Bad square tesselation algo
        for (let i = 0; i < this.columns; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                // Columns start with a new collider
                if (j === 0) {
                    current = null;
                }
                const tile = this.tiles[i + j * this.columns];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    // Use custom collider otherwise bounding box
                    if (tile.getColliders().length > 0) {
                        for (const collider of tile.getColliders()) {
                            const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                            collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);
                            collider.owner = this;
                            this._composite.addCollider(collider);
                        }
                        current = null;
                    }
                    else {
                        if (!current) {
                            current = tile.bounds;
                        }
                        else {
                            current = current.combine(tile.bounds);
                        }
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    if (current) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            if (current) {
                // if previous is the same combine it
                const prev = colliders[colliders.length - 1];
                if (prev && prev.top === current.top && prev.bottom === current.bottom) {
                    colliders[colliders.length - 1] = prev.combine(current);
                }
                else {
                    // else new collider
                    colliders.push(current);
                }
            }
        }
        for (const c of colliders) {
            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this._collider.update();
    }
    /**
     * Returns the [[Tile]] by index (row major order)
     */
    getTileByIndex(index) {
        return this.tiles[index];
    }
    /**
     * Returns the [[Tile]] by its x and y integer coordinates
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the [[Tile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const x = Math.floor((point.x - this.pos.x) / this.tileWidth);
        const y = Math.floor((point.y - this.pos.y) / this.tileHeight);
        const tile = this.getTile(x, y);
        if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {
            return tile;
        }
        return null;
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        if (!this._oldPos.equals(this.pos)) {
            this.flagCollidersDirty();
            for (let i = 0; i < this.tiles.length; i++) {
                if (this.tiles[i]) {
                    this.tiles[i].flagDirty();
                }
            }
        }
        if (this._collidersDirty) {
            this._collidersDirty = false;
            this._updateColliders();
        }
        this._token++;
        const worldBounds = engine.getWorldBounds();
        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);
        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);
        let pos = this.pos;
        const maybeParallax = this.get(ParallaxComponent);
        let parallaxOffset = Vector.One;
        if (maybeParallax) {
            const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
            parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);
            pos = pos.add(parallaxOffset);
        }
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);
        // why are we resetting pos?
        this._transform.pos = vec(this.x, this.y);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.columns);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let graphics, graphicsIndex, graphicsLen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                graphics = this.getTile(x, y).getGraphics();
                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                    // draw sprite, warning if sprite doesn't exist
                    const graphic = graphics[graphicsIndex];
                    if (graphic) {
                        if (hasGraphicsTick(graphic)) {
                            graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
                        }
                        const offsetY = this.renderFromTopOfGraphic ? 0 : (graphic.height - this.tileHeight);
                        graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));
    }
    debug(gfx) {
        const width = this.tileWidth * this.columns;
        const height = this.tileHeight * this.rows;
        const pos = Vector.Zero;
        for (let r = 0; r < this.rows + 1; r++) {
            const yOffset = vec(0, r * this.tileHeight);
            gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);
        }
        for (let c = 0; c < this.columns + 1; c++) {
            const xOffset = vec(c * this.tileWidth, 0);
            gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);
        }
        const colliders = this._composite.getColliders();
        for (const collider of colliders) {
            const grayish = Color.Gray;
            grayish.a = 0.5;
            const bounds = collider.localBounds;
            const pos = collider.worldPos.sub(this.pos);
            gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);
        }
    }
}
/**
 * TileMap Tile
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Tiles can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Tile extends Entity {
    constructor(options) {
        var _a, _b;
        super();
        this._posDirty = false;
        this._solid = false;
        this._graphics = [];
        /**
         * Current list of colliders for this tile
         */
        this._colliders = [];
        /**
         * Arbitrary data storage per tile, useful for any game specific data
         */
        this.data = new Map();
        this.x = options.x;
        this.y = options.y;
        this.map = options.map;
        this.width = options.map.tileWidth;
        this.height = options.map.tileHeight;
        this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;
        this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];
        this._recalculate();
    }
    // private _transform: TransformComponent;
    /**
     * Return the world position of the top left corner of the tile
     */
    get pos() {
        if (this._posDirty) {
            this._recalculate();
            this._posDirty = false;
        }
        return this._pos;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagCollidersDirty();
        this._solid = val;
    }
    /**
     * Current list of graphics for this tile
     */
    getGraphics() {
        return this._graphics;
    }
    /**
     * Add another [[Graphic]] to this TileMap tile
     * @param graphic
     */
    addGraphic(graphic) {
        this._graphics.push(graphic);
    }
    /**
     * Remove an instance of a [[Graphic]] from this tile
     */
    removeGraphic(graphic) {
        removeItemFromArray(graphic, this._graphics);
    }
    /**
     * Clear all graphics from this tile
     */
    clearGraphics() {
        this._graphics.length = 0;
    }
    /**
     * Returns the list of colliders
     */
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a custom collider to the [[Tile]] to use instead of it's bounds
     *
     * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the [[Tile]]
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the [[Tile]]
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    flagDirty() {
        return this._posDirty = true;
    }
    _recalculate() {
        this._pos = this.map.pos.add(vec(this.x * this.map.tileWidth, this.y * this.map.tileHeight));
        this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);
        this._posDirty = false;
    }
    get bounds() {
        if (this._posDirty) {
            this._recalculate();
        }
        return this._bounds;
    }
    get center() {
        if (this._posDirty) {
            this._recalculate();
        }
        return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);
    }
}

;// CONCATENATED MODULE: ./Camera.ts









/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new Vector(center.x, currentFocus.y);
            }
            else {
                return new Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return vec(focusX, focusY);
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends Class {
    constructor() {
        super(...arguments);
        this.transform = AffineMatrix.identity();
        this.inverse = AffineMatrix.identity();
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        this._angularVelocity = 0;
        /**
         * Get or set the camera's position
         */
        this._posChanged = false;
        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));
        /**
         * Get or set the camera's velocity
         */
        this.vel = Vector.Zero;
        /**
         * Get or set the camera's acceleration
         */
        this.acc = Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = EasingFunctions.EaseInOutCubic;
        this._easing = EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this._angularVelocity;
    }
    set angularVelocity(value) {
        this._angularVelocity = value;
    }
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._pos = watchAny(vec, () => (this._posChanged = true));
        this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this._engine = _engine;
            this._screen = _engine.screen;
            const currentRes = this._screen.resolution;
            let center = vec(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._screen.peekResolution();
                if (res) {
                    center = vec(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.y;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            // First frame bootstrap
            // Ensure camera tx is correct
            // Run update twice to ensure properties are init'd
            this.updateTransform();
            // Run strategies for first frame
            this.runStrategies(_engine, _engine.clock.elapsed());
            // Setup the first frame viewport
            this.updateViewport();
            // It's important to update the camera after strategies
            // This prevents jitter
            this.updateTransform();
            this.onInitialize(_engine);
            super.emit('initialize', new InitializeEvent(_engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    runStrategies(engine, delta) {
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, engine, delta);
        }
    }
    updateViewport() {
        // recalc viewport
        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.zoom += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        this.runStrategies(_engine, delta);
        this.updateViewport();
        // It's important to update the camera after strategies
        // This prevents jitter
        this.updateTransform();
        this._postupdate(_engine, delta);
    }
    /**
     * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
     * @param ctx Canvas context to apply transformations
     */
    draw(ctx) {
        ctx.multiply(this.transform);
    }
    updateTransform() {
        // center the camera
        const newCanvasWidth = this._screen.resolution.width / this.zoom;
        const newCanvasHeight = this._screen.resolution.height / this.zoom;
        const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);
        // Calculate camera transform
        this.transform.reset();
        this.transform.scale(this.zoom, this.zoom);
        this.transform.translate(cameraPos.x, cameraPos.y);
        this.transform.inverse(this.inverse);
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}

;// CONCATENATED MODULE: ./Trigger.ts





const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = {
            ...triggerDefaults,
            ...opts
        };
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.graphics.visible = opts.visible;
        this.body.collisionType = CollisionType.Passive;
        this.eventDispatcher = new EventDispatcher();
        this.events.on('collisionstart', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('enter', new EnterTriggerEvent(this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.events.on('collisionend', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('exit', new ExitTriggerEvent(this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        if (this.repeat !== 0) {
            this.action.call(this);
            this.repeat--;
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to execute after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}

;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts


// Add/Remove entities and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
        for (const entity of this.entities) {
            // TODO is this right?
            entity.update(_context.engine, elapsed);
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (const entity of this.entities) {
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (isAddedComponent(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (isRemovedComponent(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.active = true;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.componentAdded$.register(this);
            entity.componentRemoved$.register(this);
            // if entity has children
            entity.children.forEach((c) => this.addEntity(c));
            entity.childrenAdded$.register({
                notify: (e) => {
                    this.addEntity(e);
                }
            });
            entity.childrenRemoved$.register({
                notify: (e) => {
                    this.removeEntity(e, false);
                }
            });
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a;
        let id = 0;
        if (idOrEntity instanceof Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.active) {
            entity.kill();
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.componentAdded$.unregister(this);
            entity.componentRemoved$.unregister(this);
            // if entity has children
            entity.children.forEach((c) => this.removeEntity(c, deferred));
            entity.childrenAdded$.clear();
            entity.childrenRemoved$.clear();
            // stats
            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
                this._world.context.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (const entity of this._entitiesToRemove) {
            if (entity.active) {
                continue;
            }
            this.removeEntity(entity, false);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter(e => e.name === name);
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};

;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends Observable {
    constructor(types) {
        super();
        this._entities = [];
        if (types[0] instanceof Function) {
            this.types = types.map(T => (new T).type);
        }
        else {
            this.types = types;
        }
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = buildTypeKey(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new AddedEntity(entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new RemovedEntity(entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof Entity) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
    contain(type) {
        return this.types.indexOf(type) > -1;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[buildTypeKey(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[buildTypeKey(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            // If the component being removed from an entity is a part of a query,
            // it is now disqualified from that query, remove it
            if (this._queries[queryType].contain(component.type)) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new Query(types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = buildTypeKey(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (this.initialized && system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Initialize all systems in the manager
     *
     * Systems added after initialize() will be initialized on add
     */
    initialize() {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world.context);
                }
            }
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(context, delta);
            }
        }
        for (const s of systems) {
            // Get entities that match the system types, pre-sort
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            // Initialize entities if needed
            if (context instanceof Scene) {
                for (const entity of entities) {
                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
                }
            }
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(context, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new QueryManager(this);
        this.entityManager = new EntityManager(this);
        this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        if (type === SystemType.Update) {
            this.entityManager.updateEntities(this.context, delta);
        }
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}

;// CONCATENATED MODULE: ./Collision/Integrator.ts

class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsedMs) {
        const seconds = elapsedMs / 1000;
        // This code looks a little wild, but it's to avoid creating any new Vector instances
        // integration is done in a tight loop so this is key to avoid GC'ing
        motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));
        transform.pos
            .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)
            .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        const rotation = transform.rotation + motion.angularVelocity * seconds;
        transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);
        const tx = transform.get();
        tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);
    }
}
// Scratch vectors to avoid allocation
EulerIntegrator._POS = new Vector(0, 0);
EulerIntegrator._SCALE = new Vector(1, 1);
EulerIntegrator._ACC = new Vector(0, 0);
EulerIntegrator._VEL = new Vector(0, 0);
EulerIntegrator._VEL_ACC = new Vector(0, 0);
EulerIntegrator._SCALE_FACTOR = new Vector(0, 0);

;// CONCATENATED MODULE: ./Collision/MotionSystem.ts







class MotionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(entities, elapsedMs) {
        let transform;
        let motion;
        for (let i = 0; i < entities.length; i++) {
            transform = entities[i].get(TransformComponent);
            motion = entities[i].get(MotionComponent);
            const optionalBody = entities[i].get(BodyComponent);
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(Physics.gravity);
            }
            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
            // Update transform and motion based on Euler linear algebra
            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts




/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver {
    constructor() {
        this.directionMap = new Map();
        this.distanceMap = new Map();
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Sort contacts by distance to avoid artifacts with seams
        // It's important to solve in a specific order
        contacts.sort((a, b) => {
            const aDist = this.distanceMap.get(a.id);
            const bDist = this.distanceMap.get(b.id);
            return aDist - bDist;
        });
        for (const contact of contacts) {
            // Solve position first in arcade
            this.solvePosition(contact);
            // Solve velocity second in arcade
            this.solveVelocity(contact);
        }
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        for (const contact of contacts) {
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);
            this.distanceMap.set(contact.id, distance);
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            if (contact.isCanceled()) {
                continue;
            }
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
            }
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    solvePosition(contact) {
        var _a, _b;
        const epsilon = .0001;
        // if bounds no longer intersect skip to the next
        // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles
        if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {
            // Cancel the contact to prevent and solving
            contact.cancel();
            return;
        }
        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
            // Cancel near 0 mtv collisions
            contact.cancel();
            return;
        }
        let mtv = contact.mtv;
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                return;
            }
            if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
                // split overlaps if both are Active
                mtv = mtv.scale(0.5);
            }
            // Resolve overlaps
            if (bodyA.collisionType === CollisionType.Active) {
                bodyA.globalPos.x -= mtv.x;
                bodyA.globalPos.y -= mtv.y;
                colliderA.update(bodyA.transform.get());
            }
            if (bodyB.collisionType === CollisionType.Active) {
                bodyB.globalPos.x += mtv.x;
                bodyB.globalPos.y += mtv.y;
                colliderB.update(bodyB.transform.get());
            }
        }
    }
    solveVelocity(contact) {
        var _a, _b;
        if (contact.isCanceled()) {
            return;
        }
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                return;
            }
            const normal = contact.normal;
            const opposite = normal.negate();
            if (bodyA.collisionType === CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform when sliding off
                if (bodyA.vel.normalize().dot(opposite) < 0) {
                    // Cancel out velocity opposite direction of collision normal
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
            }
            if (bodyB.collisionType === CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform
                if (bodyB.vel.normalize().dot(normal) < 0) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts


/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new Vector(0, 0);
        /**
         * Original contact velocity combined with bounciness
         */
        this.originalVelocityAndRestitution = 0;
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.globalPos);
            this.bToContact = this.point.sub(bodyB.globalPos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity between bodyA and bodyB
     */
    getRelativeVelocity() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return Vector.Zero;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts








class RealisticSolver {
    constructor() {
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (const contact of contacts) {
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                for (const point of contact.points) {
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.globalPos);
                    const bToContact = point.sub(bodyB.globalPos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = 1.0 / normalMass;
                    contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;
                    // Calculate relative velocity before solving to accurately do restitution
                    const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;
                    const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());
                    contactPoints[pointIndex].originalVelocityAndRestitution = 0;
                    if (relativeVelocity < -0.1) { // TODO what's a good threshold here?
                        contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;
                    }
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (Physics.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (const contact of contacts) {
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (const contact of contacts) {
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (const c of contacts) {
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                for (const point of contactPoints) {
                    if (Physics.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.positionIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = Physics.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = Physics.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce * point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === CollisionType.Active) {
                            // TODO make applyPseudoImpulse function?
                            const impulseForce = impulse.negate().scale(bodyA.inverseMass);
                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyA.globalPos = bodyA.globalPos.add(impulseForce);
                            if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                            }
                        }
                        if (bodyB.collisionType === CollisionType.Active) {
                            const impulseForce = impulse.scale(bodyB.inverseMass);
                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyB.globalPos = bodyB.globalPos.add(impulseForce);
                            if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                            }
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.velocityIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    // Friction constraint
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity * point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    // Bounce constraint
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // Per Erin it is a mistake to apply the restitution inside the iteration
                        // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses
                        let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts








class CollisionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._realisticSolver = new RealisticSolver();
        this._arcadeSolver = new ArcadeSolver();
        this._processor = new DynamicTreeCollisionProcessor();
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
    }
    notify(message) {
        if (isAddedSystemEntity(message)) {
            const colliderComponent = message.data.get(ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        }
        else {
            const colliderComponent = message.data.get(ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        }
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    update(entities, elapsedMs) {
        var _a, _b, _c, _d;
        if (!Physics.enabled) {
            return;
        }
        // Collect up all the colliders and update them
        let colliders = [];
        for (const entity of entities) {
            const colliderComp = entity.get(ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
                colliderComp.update();
                if (collider instanceof CompositeCollider) {
                    const compositeColliders = collider.getColliders();
                    colliders = colliders.concat(compositeColliders);
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders);
        // Run broadphase on all colliders and locates potential collisions
        const pairs = this._processor.broadphase(colliders, elapsedMs);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities aren't overlapping
        contacts = solver.solve(contacts);
        // Record contacts for start/end
        for (const contact of contacts) {
            // Process composite ids, things with the same composite id are treated as the same collider for start/end
            const index = contact.id.indexOf('|');
            if (index > 0) {
                const compositeId = contact.id.substring(index + 1);
                this._currentFrameContacts.set(compositeId, contact);
            }
            else {
                this._currentFrameContacts.set(contact.id, contact);
            }
        }
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex);
    }
    runContactStartEnd() {
        // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));
                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));
                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));
                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));
            }
        }
        // find all contacts that have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));
                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));
                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));
                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Animation.ts




var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is play backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
/**
 * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]
 *
 * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]
 */
class Animation extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.events = new EventDispatcher(); // TODO replace with new Emitter
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this.timeScale = 1;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._direction = 1; // TODO only used in ping-pong
        this._done = false;
        this._playing = true;
        this._reversed = false;
        this.frames = options.frames;
        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation({
            frames: this.frames.map((f) => ({ ...f })),
            frameDuration: this.frameDuration,
            reverse: this._reversed,
            strategy: this.strategy,
            ...this.cloneGraphicOptions()
        });
    }
    get width() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame) {
            return Math.abs(maybeFrame.graphic.width * this.scale.x);
        }
        return 0;
    }
    get height() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame) {
            return Math.abs(maybeFrame.graphic.height * this.scale.y);
        }
        return 0;
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => frameIndices.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrameMs
            })),
            strategy: strategy
        });
    }
    /**
     * Returns the current Frame of the animation
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = (this._reversed && this._direction === 1) ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
            this.events.emit('frame', maybeFrame);
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = clamp(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._direction >= this.frames.length) {
                    this._direction = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._direction < 0) {
                    this._direction = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._direction % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', this.currentFrame);
        }
        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = Logger.getInstance();

;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts



class GraphicsGroup extends Graphic {
    constructor(options) {
        super(options);
        this.members = [];
        this.members = options.members;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup({
            members: [...this.members],
            ...this.cloneGraphicOptions()
        });
    }
    _updateDimensions() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        for (const member of this.members) {
            ex.save();
            ex.translate(x, y);
            member.graphic.draw(ex, member.pos.x, member.pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Configurable.ts
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}

;// CONCATENATED MODULE: ./Particles.ts












/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super();
        this.position = new Vector(0, 0);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = Color.White;
        this.endColor = Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = Color.White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        this.visible = true;
        this.isOffscreen = false;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = (position || this.position).add(this.emitter.pos);
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
        this.addComponent((this.transform = new TransformComponent()));
        this.addComponent((this.graphics = new GraphicsComponent()));
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // TODO wut
        if (this.particleSprite) {
            this.graphics.opacity = this.opacity;
            this.graphics.use(this.particleSprite);
        }
        else {
            this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                this.graphics.opacity = this.opacity;
                const tmpColor = this._currentColor.clone();
                tmpColor.a = 1;
                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
                ctx.restore();
            };
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // todo wut
        this.graphics.opacity = this.opacity;
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = [];
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new Vector(0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = null;
        /**
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /**
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = Color.White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = Color.White;
        this._sprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = { ...config };
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
        this.body.collisionType = CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new Random();
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
        return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
        super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
        return this._sprite;
    }
    set particleSprite(val) {
        if (val) {
            this._sprite = val;
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            this.particles.push(p);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.add(p);
            }
        }
    }
    clearParticles() {
        this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
        const vel = randomInRange(this.minVel, this.maxVel, this.random);
        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = randomInRange(0, this.width, this.random);
            ranY = randomInRange(0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = randomInRange(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
            p.graphics.opacity = this.opacity;
            p.graphics.use(this._sprite);
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        var _a;
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            removeItemFromArray(this.deadParticles[i], this.particles);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
            }
        }
        this.deadParticles.length = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts









class GraphicsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = 0;
        this._token = 0;
        this._sortedTransforms = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
    }
    get sortedTransforms() {
        return this._sortedTransforms;
    }
    initialize(scene) {
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    preupdate() {
        // Graphics context could be switched to fallback in a new frame
        this._graphicsContext = this._engine.graphicsContext;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return a.z - b.z;
            });
            this._zHasChanged = false;
        }
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            this._sortedTransforms.push(tx);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        }
        else {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
            }
        }
    }
    update(_entities, delta) {
        this._token++;
        let graphics;
        // This is a performance enhancement, most things are in world space
        // so if we can only do this once saves a ton of transform updates
        this._graphicsContext.save();
        if (this._camera) {
            this._camera.draw(this._graphicsContext);
        }
        for (const transform of this._sortedTransforms) {
            const entity = transform.owner;
            // If the entity is offscreen skip
            if (entity.hasTag('ex.offscreen')) {
                continue;
            }
            graphics = entity.get(GraphicsComponent);
            // Exit if graphics set to not visible
            if (!graphics.visible) {
                continue;
            }
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            if (transform.coordPlane === CoordPlane.Screen) {
                this._graphicsContext.restore();
            }
            this._graphicsContext.save();
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(delta, this._token);
            // Apply parallax
            const parallax = entity.get(ParallaxComponent);
            if (parallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);
                const parallaxOffset = this._camera.pos.scale(oneMinusFactor);
                this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);
            }
            // Position the entity + estimate lag
            this._applyTransform(entity);
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, delta);
            }
            // TODO remove this hack on the particle redo
            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;
            this._graphicsContext.opacity = graphics.opacity * particleOpacity;
            // Draw the graphics component
            this._drawGraphicsComponent(graphics);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, delta);
            }
            this._graphicsContext.restore();
            // Reset the transform back to the original world space
            if (transform.coordPlane === CoordPlane.Screen) {
                this._graphicsContext.save();
                if (this._camera) {
                    this._camera.draw(this._graphicsContext);
                }
            }
        }
        this._graphicsContext.restore();
    }
    _drawGraphicsComponent(graphicsComponent) {
        var _a, _b;
        if (graphicsComponent.visible) {
            // this should be moved to the graphics system
            for (const layer of graphicsComponent.layers.get()) {
                for (const { graphic, options } of layer.graphics) {
                    let anchor = graphicsComponent.anchor;
                    let offset = graphicsComponent.offset;
                    if (options === null || options === void 0 ? void 0 : options.anchor) {
                        anchor = options.anchor;
                    }
                    if (options === null || options === void 0 ? void 0 : options.offset) {
                        offset = options.offset;
                    }
                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                    const offsetX = -graphic.width * anchor.x + offset.x;
                    const offsetY = -graphic.height * anchor.y + offset.y;
                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
                        if (graphic instanceof GraphicsGroup) {
                            for (const g of graphic.members) {
                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                        else {
                            /* istanbul ignore next */
                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                        }
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(BodyComponent);
            let interpolatedPos = transform.pos;
            let interpolatedScale = transform.scale;
            let interpolatedRotation = transform.rotation;
            if (optionalBody) {
                if (this._engine.fixedUpdateFps &&
                    optionalBody.__oldTransformCaptured &&
                    optionalBody.enableFixedUpdateInterpolate) {
                    // Interpolate graphics if needed
                    const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);
                    interpolatedPos = transform.pos.scale(blend).add(optionalBody.oldPos.scale(1.0 - blend));
                    interpolatedScale = transform.scale.scale(blend).add(optionalBody.oldScale.scale(1.0 - blend));
                    // Rotational lerp https://stackoverflow.com/a/30129248
                    const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);
                    const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);
                    interpolatedRotation = Math.atan2(sine, cosine);
                }
            }
            if (transform) {
                this._graphicsContext.z = transform.z;
                this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);
                this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);
                this._graphicsContext.rotate(interpolatedRotation);
            }
        }
    }
}

;// CONCATENATED MODULE: ./Debug/DebugSystem.ts









class DebugSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform'];
        this.systemType = SystemType.Draw;
        this.priority = 999; // lowest priority
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
        var _a;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let debugDraw;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (const entity of entities) {
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = Vector.Zero;
            const lineHeight = vec(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });
                }
                if (txSettings.showAll || txSettings.showPositionLabel) {
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showZIndex) {
                    this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            debugDraw = entity.get(DebugGraphicsComponent);
            if (debugDraw) {
                if (!debugDraw.useTransform) {
                    this._graphicsContext.restore();
                }
                debugDraw.draw(this._graphicsContext);
                if (!debugDraw.useTransform) {
                    this._graphicsContext.save();
                    this._applyTransform(entity);
                }
            }
            body = entity.get(BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            motion = entity.get(MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = vec(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = vec(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Input/PointerSystem.ts





/**
 * The PointerSystem is responsible for dispatching pointer events to entities
 * that need them.
 *
 * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use
 * the [[Collider]]'s shape for pointer events.
 */
class PointerSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.pointer'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseColliderShape = false;
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseGraphicsBounds = false;
        this.lastFrameEntityToPointers = new Map();
        this.currentFrameEntityToPointers = new Map();
        this._sortedTransforms = [];
        this._sortedEntities = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    preupdate() {
        // event receiver might change per frame
        this._receiver = this._engine.input.pointers;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return b.z - a.z;
            });
            this._sortedEntities = this._sortedTransforms.map(t => t.owner);
            this._zHasChanged = false;
        }
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            this._sortedTransforms.push(tx);
            this._sortedEntities.push(tx.owner);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        }
        else {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
                this._sortedEntities.splice(index, 1);
            }
        }
    }
    entityCurrentlyUnderPointer(entity, pointerId) {
        return this.currentFrameEntityToPointers.has(entity.id) &&
            this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entityWasUnderPointer(entity, pointerId) {
        return this.lastFrameEntityToPointers.has(entity.id) &&
            this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entered(entity, pointerId) {
        return this.entityCurrentlyUnderPointer(entity, pointerId) &&
            !this.lastFrameEntityToPointers.has(entity.id);
    }
    left(entity, pointerId) {
        return !this.currentFrameEntityToPointers.has(entity.id) &&
            this.entityWasUnderPointer(entity, pointerId);
    }
    addPointerToEntity(entity, pointerId) {
        if (!this.currentFrameEntityToPointers.has(entity.id)) {
            this.currentFrameEntityToPointers.set(entity.id, [pointerId]);
            return;
        }
        const pointers = this.currentFrameEntityToPointers.get(entity.id);
        this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));
    }
    update(_entities) {
        // Locate all the pointer/entity mappings
        this._processPointerToEntity(this._sortedEntities);
        // Dispatch pointer events on entities
        this._dispatchEvents(this._sortedEntities);
        // Clear last frame's events
        this._receiver.update();
        this.lastFrameEntityToPointers.clear();
        this.lastFrameEntityToPointers = new Map(this.currentFrameEntityToPointers);
        this.currentFrameEntityToPointers.clear();
        this._receiver.clear();
    }
    _processPointerToEntity(entities) {
        var _a;
        let transform;
        let collider;
        let graphics;
        let pointer;
        // TODO probably a spatial partition optimization here to quickly query bounds for pointer
        // doesn't seem to cause issues tho for perf
        // Pre-process find entities under pointers
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            pointer = (_a = entity.get(PointerComponent)) !== null && _a !== void 0 ? _a : new PointerComponent;
            // Check collider contains pointer
            collider = entity.get(ColliderComponent);
            if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {
                collider.update();
                const geom = collider.get();
                if (geom) {
                    for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
                        if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
                            this.addPointerToEntity(entity, pointerId);
                        }
                    }
                }
            }
            // Check graphics contains pointer
            graphics = entity.get(GraphicsComponent);
            if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {
                const graphicBounds = graphics.localBounds.transform(transform.get().matrix);
                for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
                    if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
                        this.addPointerToEntity(entity, pointerId);
                    }
                }
            }
        }
    }
    _processDownAndEmit(entity) {
        const lastDownPerPointer = new Map();
        // Loop through down and dispatch to entities
        for (const event of this._receiver.currentFrameDown) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointerdown', event);
                if (this._receiver.isDragStart(event.pointerId)) {
                    entity.events.emit('pointerdragstart', event);
                }
            }
            lastDownPerPointer.set(event.pointerId, event);
        }
        return lastDownPerPointer;
    }
    _processUpAndEmit(entity) {
        const lastUpPerPointer = new Map();
        // Loop through up and dispatch to entities
        for (const event of this._receiver.currentFrameUp) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointerup', event);
                if (this._receiver.isDragEnd(event.pointerId)) {
                    entity.events.emit('pointerdragend', event);
                }
            }
            lastUpPerPointer.set(event.pointerId, event);
        }
        return lastUpPerPointer;
    }
    _processMoveAndEmit(entity) {
        const lastMovePerPointer = new Map();
        // Loop through move and dispatch to entities
        for (const event of this._receiver.currentFrameMove) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                // move
                entity.events.emit('pointermove', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragmove', event);
                }
            }
            lastMovePerPointer.set(event.pointerId, event);
        }
        return lastMovePerPointer;
    }
    _processEnterLeaveAndEmit(entity, lastUpDownMoveEvents) {
        // up, down, and move are considered for enter and leave
        for (const event of lastUpDownMoveEvents) {
            // enter
            if (event.active && entity.active && this.entered(entity, event.pointerId)) {
                entity.events.emit('pointerenter', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragenter', event);
                }
                break;
            }
            if (event.active && entity.active &&
                // leave can happen on move
                (this.left(entity, event.pointerId) ||
                    // or leave can happen on pointer up
                    (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {
                entity.events.emit('pointerleave', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragleave', event);
                }
                break;
            }
        }
    }
    _processCancelAndEmit(entity) {
        // cancel
        for (const event of this._receiver.currentFrameCancel) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointercancel', event);
            }
        }
    }
    _processWheelAndEmit(entity) {
        // wheel
        for (const event of this._receiver.currentFrameWheel) {
            // Currently the wheel only fires under the primary pointer '0'
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {
                entity.events.emit('pointerwheel', event);
            }
        }
    }
    _dispatchEvents(entities) {
        const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());
        const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());
        // Filter preserves z order
        const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));
        let lastMovePerPointer;
        let lastUpPerPointer;
        let lastDownPerPointer;
        // Dispatch events in entity z order
        for (const entity of entitiesWithEvents) {
            lastDownPerPointer = this._processDownAndEmit(entity);
            lastUpPerPointer = this._processUpAndEmit(entity);
            lastMovePerPointer = this._processMoveAndEmit(entity);
            const lastUpDownMoveEvents = [
                ...lastMovePerPointer.values(),
                ...lastDownPerPointer.values(),
                ...lastUpPerPointer.values()
            ];
            this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);
            this._processCancelAndEmit(entity);
            this._processWheelAndEmit(entity);
        }
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts


class ActionsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.actions'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._actions = [];
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const action = entityAddedOrRemoved.data.get(ActionsComponent);
            this._actions.push(action);
        }
        else {
            const action = entityAddedOrRemoved.data.get(ActionsComponent);
            const index = this._actions.indexOf(action);
            if (index > -1) {
                this._actions.splice(index, 1);
            }
        }
    }
    update(_entities, delta) {
        for (const actions of this._actions) {
            actions.update(delta);
        }
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricEntityComponent.ts

class IsometricEntityComponent extends Component {
    /**
     * Specify the isometric map to use to position this entity's z-index
     * @param map
     */
    constructor(map) {
        super();
        this.type = 'ex.isometricentity';
        /**
         * Vertical "height" in the isometric world
         */
        this.elevation = 0;
        this.map = map;
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricEntitySystem.ts



class IsometricEntitySystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.isometricentity'];
        this.systemType = SystemType.Update;
        this.priority = 99;
    }
    update(entities, _delta) {
        let transform;
        let iso;
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            iso = entity.get(IsometricEntityComponent);
            const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);
            const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;
            transform.z = newZ;
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/OffscreenSystem.ts







class OffscreenSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._camera = scene.camera;
    }
    update(entities) {
        let transform;
        let graphics;
        let maybeParallax;
        for (const entity of entities) {
            graphics = entity.get(GraphicsComponent);
            transform = entity.get(TransformComponent);
            maybeParallax = entity.get(ParallaxComponent);
            let parallaxOffset;
            if (maybeParallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
                parallaxOffset = this._camera.pos.scale(oneMinusFactor);
            }
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
            if (entityOffscreen && !entity.hasTag('ex.offscreen')) {
                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addTag('ex.offscreen');
            }
            if (!entityOffscreen && entity.hasTag('ex.offscreen')) {
                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeTag('ex.offscreen');
            }
        }
    }
    _isOffscreen(transform, graphics, parallaxOffset) {
        if (transform.coordPlane === CoordPlane.World) {
            let bounds = graphics.localBounds;
            if (parallaxOffset) {
                bounds = bounds.translate(parallaxOffset);
            }
            const transformedBounds = bounds.transform(transform.get().matrix);
            const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);
            return graphicsOffscreen;
        }
        else {
            // TODO screen coordinates
            return false;
        }
    }
}

;// CONCATENATED MODULE: ./Scene.ts





















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends Class {
    constructor() {
        super();
        this._logger = Logger.getInstance();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new World(this);
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // Initialize systems
        // Update
        this.world.add(new ActionsSystem());
        this.world.add(new MotionSystem());
        this.world.add(new CollisionSystem());
        this.world.add(new PointerSystem());
        this.world.add(new IsometricEntitySystem());
        // Draw
        this.world.add(new OffscreenSystem());
        this.world.add(new GraphicsSystem());
        this.world.add(new DebugSystem());
    }
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Trigger;
        });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof TileMap;
        });
    }
    get timers() {
        return this._timers;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_context) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_context) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     *
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     *
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            // Initialize camera first
            this.camera._initialize(engine);
            this.world.systemManager.initialize();
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(context) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(context) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        this.world.update(SystemType.Update, delta);
        // Camera last keeps renders smooth that are based on entity/actor
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        this._collectActorStats(engine);
        this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     *
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        var _a;
        this._predraw(ctx, delta);
        this.world.update(SystemType.Draw, delta);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof Timer) {
            if (!contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.emit('entityremoved', { target: entity });
            this.world.remove(entity);
        }
        if (entity instanceof Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
     *
     * By default entities use deferred removal
     * @param deferred
     */
    clear(deferred = true) {
        for (const entity of this.entities) {
            this.world.remove(entity, deferred);
        }
        for (const timer of this.timers) {
            this.removeTimer(timer);
        }
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const screenElements = this.actors.filter((a) => a instanceof ScreenElement);
        for (const _ui of screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (isScreenElement(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessMode.ts
var ColorBlindnessMode;
(function (ColorBlindnessMode) {
    ColorBlindnessMode["Protanope"] = "Protanope";
    ColorBlindnessMode["Deuteranope"] = "Deuteranope";
    ColorBlindnessMode["Tritanope"] = "Tritanope";
})(ColorBlindnessMode || (ColorBlindnessMode = {}));

;// CONCATENATED MODULE: ./Graphics/PostProcessor/color-blind-fragment.glsl
/* harmony default export */ const color_blind_fragment = ("#version 300 es\r\nprecision mediump float;\r\n// our texture\r\nuniform sampler2D u_image;\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// color blind type\r\nuniform int u_type;\r\n\r\n// simulation?\r\nuniform bool u_simulate;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec4 o =  texture(u_image, v_texcoord);\r\n  // RGB to LMS matrix conversion\r\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\r\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\r\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\r\n  // Simulate color blindness\r\n  float l;\r\n  float m;\r\n  float s;\r\n  //MODE CODE//\r\n  if (u_type == 0) {\r\n    // Protanope\r\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\r\n  } else if (u_type == 1) {\r\n    // Deuteranope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\r\n  } else if (u_type == 2) {\r\n    // Tritanope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\r\n  }\r\n\r\n  // LMS to RGB matrix conversion\r\n  vec4 error; // simulate the colors\r\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\r\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\r\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\r\n  error.a = 1.0;\r\n  vec4 diff = o - error;\r\n  vec4 correction; // correct the colors\r\n  correction.r = 0.0;\r\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\r\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\r\n  correction = o + correction;\r\n  correction.a = o.a;\r\n  //SIMULATE//\r\n\r\n  // sim \r\n  if (u_simulate) {\r\n    fragColor = error.rgba;\r\n  } else {\r\n    fragColor = correction.rgba;\r\n  }\r\n}");
;// CONCATENATED MODULE: ./Graphics/PostProcessor/ScreenShader.ts



/**
 * Helper that defines a whole screen renderer, just provide a fragment source!
 *
 * Currently supports 1 varying
 * - vec2 a_texcoord between 0-1 which corresponds to screen position
 */
class ScreenShader {
    constructor(fragmentSource) {
        this._shader = new Shader({
            vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_texcoord;
      out vec2 v_texcoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_texcoord;
      }`,
            fragmentSource: fragmentSource
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new VertexBuffer({
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                1, 1, 1, 1
            ])
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_texcoord', 2]
            ]
        });
        this._buffer.upload();
    }
    getShader() {
        return this._shader;
    }
    getLayout() {
        return this._layout;
    }
}

;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts



class ColorBlindnessPostProcessor {
    constructor(_colorBlindnessMode, simulate = false) {
        this._colorBlindnessMode = _colorBlindnessMode;
        this._simulate = false;
        this._simulate = simulate;
    }
    initialize(_gl) {
        this._shader = new ScreenShader(color_blind_fragment);
        this.simulate = this._simulate;
        this.colorBlindnessMode = this._colorBlindnessMode;
    }
    getShader() {
        return this._shader.getShader();
    }
    getLayout() {
        return this._shader.getLayout();
    }
    set colorBlindnessMode(colorBlindMode) {
        this._colorBlindnessMode = colorBlindMode;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {
                shader.setUniformInt('u_type', 0);
            }
            else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {
                shader.setUniformInt('u_type', 1);
            }
            else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {
                shader.setUniformInt('u_type', 2);
            }
        }
    }
    get colorBlindnessMode() {
        return this._colorBlindnessMode;
    }
    set simulate(value) {
        this._simulate = value;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            shader.setUniformBoolean('u_simulate', value);
        }
    }
    get simulate() {
        return this._simulate;
    }
}

;// CONCATENATED MODULE: ./Debug/DebugFlags.ts



class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
        this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);
    }
    /**
     * Correct colors for a specified color blindness
     * @param colorBlindness
     */
    correct(colorBlindness) {
        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = false;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Simulate colors for a specified color blindness
     * @param colorBlindness
     */
    simulate(colorBlindness) {
        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = true;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Remove color blindness post processor
     */
    clear() {
        this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
    }
}

;// CONCATENATED MODULE: ./Debug/Debug.ts


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: true,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            showPosition: false,
            showPositionLabel: false,
            positionColor: Color.Yellow,
            showZIndex: false,
            showScale: false,
            scaleColor: Color.Green,
            showRotation: false,
            rotationColor: Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: Color.Green
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: Color.Cyan,
            showCollisionContacts: true,
            collisionContactColor: Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: Color.Yellow,
            showAcceleration: false,
            accelerationColor: Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: Color.Red,
            showZoom: false
        };
        this._engine = engine;
        this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
    /**
     * Switch the current excalibur clock with the [[TestClock]] and return
     * it in the same running state.
     *
     * This is useful when you need to debug frame by frame.
     */
    useTestClock() {
        const clock = this._engine.clock;
        const wasRunning = clock.isRunning();
        clock.stop();
        const testClock = clock.toTestClock();
        if (wasRunning) {
            testClock.start();
        }
        this._engine.clock = testClock;
        return testClock;
    }
    /**
     * Switch the current excalibur clock with the [[StandardClock]] and
     * return it in the same running state.
     *
     * This is useful when you need to switch back to normal mode after
     * debugging.
     */
    useStandardClock() {
        const currentClock = this._engine.clock;
        const wasRunning = currentClock.isRunning();
        currentClock.stop();
        const standardClock = currentClock.toStandardClock();
        if (wasRunning) {
            standardClock.start();
        }
        this._engine.clock = standardClock;
        return standardClock;
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}

;// CONCATENATED MODULE: ./Input/PointerScope.ts
/**
 * Determines the scope of handling mouse/touch events.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));

;// CONCATENATED MODULE: ./Input/Keyboard.ts



/**
 * Enum representing physical input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    Keys["ControlLeft"] = "ControlLeft";
    Keys["ControlRight"] = "ControlRight";
    Keys["MetaLeft"] = "MetaLeft";
    Keys["MetaRight"] = "MetaRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // FUNCTION KEYS
    Keys["F1"] = "F1";
    Keys["F2"] = "F2";
    Keys["F3"] = "F3";
    Keys["F4"] = "F4";
    Keys["F5"] = "F5";
    Keys["F6"] = "F6";
    Keys["F7"] = "F7";
    Keys["F8"] = "F8";
    Keys["F9"] = "F9";
    Keys["F10"] = "F10";
    Keys["F11"] = "F11";
    Keys["F12"] = "F12";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Backspace"] = "Backspace";
    Keys["Delete"] = "Delete";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
    Keys["Enter"] = "Enter";
    Keys["NumpadEnter"] = "NumpadEnter";
    Keys["ContextMenu"] = "ContextMenu";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends Class {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
        this._handleKeyDown = (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        };
        this._handleKeyUp = (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        };
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', this._handleKeyUp);
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', this._handleKeyDown);
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
    /**
     * Trigger a manual key event
     * @param type
     * @param key
     * @param character
     */
    triggerEvent(type, key, character) {
        if (type === 'down') {
            this._handleKeyDown(new KeyboardEvent('keydown', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
        if (type === 'up') {
            this._handleKeyUp(new KeyboardEvent('keyup', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
    }
}

;// CONCATENATED MODULE: ./Input/Gamepad.ts


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends Class {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends Class {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));

;// CONCATENATED MODULE: ./Util/Browser.ts
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}

;// CONCATENATED MODULE: ./Math/global-coordinates.ts

class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}

;// CONCATENATED MODULE: ./Input/PointerEvent.ts
class PointerEvent {
    constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {
        this.type = type;
        this.pointerId = pointerId;
        this.button = button;
        this.pointerType = pointerType;
        this.coordinates = coordinates;
        this.nativeEvent = nativeEvent;
        this.active = true;
    }
    cancel() {
        this.active = false;
    }
    get pagePos() {
        return this.coordinates.pagePos;
    }
    get screenPos() {
        return this.coordinates.screenPos;
    }
    get worldPos() {
        return this.coordinates.worldPos;
    }
    ;
}

;// CONCATENATED MODULE: ./Input/WheelEvent.ts
class WheelEvent {
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this.active = true;
    }
    cancel() {
        this.active = false;
    }
}

;// CONCATENATED MODULE: ./Input/PointerAbstraction.ts


class PointerAbstraction extends Class {
    constructor() {
        super();
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = Vector.Zero;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = Vector.Zero;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = Vector.Zero;
        this._onPointerMove = (ev) => {
            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this._onPointerDown = (ev) => {
            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
}

;// CONCATENATED MODULE: ./Input/WheelDeltaMode.ts
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));

;// CONCATENATED MODULE: ./Input/NativePointerButton.ts
/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));

;// CONCATENATED MODULE: ./Input/PointerButton.ts
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));

;// CONCATENATED MODULE: ./Input/PointerType.ts
/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));

;// CONCATENATED MODULE: ./Input/PointerEventReceiver.ts













/**
 * Is this event a native touch event?
 */
function isTouchEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;
}
/**
 * Is this event a native pointer event
 */
function isPointerEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;
}
/**
 * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates
 */
class PointerEventReceiver extends Class {
    constructor(target, engine) {
        super();
        this.target = target;
        this.engine = engine;
        this.primary = new PointerAbstraction();
        this._activeNativePointerIdsToNormalized = new Map();
        this.lastFramePointerCoords = new Map();
        this.currentFramePointerCoords = new Map();
        this.currentFramePointerDown = new Map();
        this.lastFramePointerDown = new Map();
        this.currentFrameDown = [];
        this.currentFrameUp = [];
        this.currentFrameMove = [];
        this.currentFrameCancel = [];
        this.currentFrameWheel = [];
        this._pointers = [this.primary];
        this._boundHandle = this._handle.bind(this);
        this._boundWheel = this._handleWheel.bind(this);
    }
    /**
     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
     * handlers.
     * @param target
     * @param engine
     */
    recreate(target, engine) {
        const eventReceiver = new PointerEventReceiver(target, engine);
        eventReceiver.primary = this.primary;
        eventReceiver._pointers = this._pointers;
        return eventReceiver;
    }
    /**
     * Locates a specific pointer by id, creates it if it doesn't exist
     * @param index
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new PointerAbstraction());
            }
        }
        return this._pointers[index];
    }
    /**
     * The number of pointers currently being tracked by excalibur
     */
    count() {
        return this._pointers.length;
    }
    /**
     * Is the specified pointer id down this frame
     * @param pointerId
     */
    isDown(pointerId) {
        var _a;
        return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Was the specified pointer id down last frame
     * @param pointerId
     */
    wasDown(pointerId) {
        var _a;
        return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    isDragging(pointerId) {
        return this.isDown(pointerId);
    }
    /**
     * Whether the Pointer just started dragging.
     */
    isDragStart(pointerId) {
        return this.isDown(pointerId) && !this.wasDown(pointerId);
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    isDragEnd(pointerId) {
        return !this.isDown(pointerId) && this.wasDown(pointerId);
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Called internally by excalibur
     *
     * Updates the current frame pointer info and emits raw pointer events
     *
     * This does not emit events to entities, see PointerSystem
     */
    update() {
        this.lastFramePointerDown = new Map(this.currentFramePointerDown);
        this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
        for (const event of this.currentFrameDown) {
            this.emit('down', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('down', event);
            this.primary.emit('pointerdown', event);
        }
        for (const event of this.currentFrameUp) {
            this.emit('up', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('up', event);
        }
        for (const event of this.currentFrameMove) {
            this.emit('move', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('move', event);
        }
        for (const event of this.currentFrameCancel) {
            this.emit('cancel', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('cancel', event);
        }
        for (const event of this.currentFrameWheel) {
            this.emit('wheel', event);
            this.primary.emit('pointerwheel', event);
        }
    }
    /**
     * Clears the current frame event and pointer data
     */
    clear() {
        for (const event of this.currentFrameUp) {
            this.currentFramePointerCoords.delete(event.pointerId);
            const ids = this._activeNativePointerIdsToNormalized.entries();
            for (const [native, normalized] of ids) {
                if (normalized === event.pointerId) {
                    this._activeNativePointerIdsToNormalized.delete(native);
                }
            }
        }
        this.currentFrameDown.length = 0;
        this.currentFrameUp.length = 0;
        this.currentFrameMove.length = 0;
        this.currentFrameCancel.length = 0;
        this.currentFrameWheel.length = 0;
    }
    /**
     * Initializes the pointer event receiver so that it can start listening to native
     * browser events.
     */
    init() {
        // Disabling the touch action avoids browser/platform gestures from firing on the canvas
        // It is important on mobile to have touch action 'none'
        // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not
        if (this.target === this.engine.canvas) {
            this.engine.canvas.style.touchAction = 'none';
        }
        else {
            document.body.style.touchAction = 'none';
        }
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.addEventListener('pointerdown', this._boundHandle);
            this.target.addEventListener('pointerup', this._boundHandle);
            this.target.addEventListener('pointermove', this._boundHandle);
            this.target.addEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.addEventListener('touchstart', this._boundHandle);
            this.target.addEventListener('touchend', this._boundHandle);
            this.target.addEventListener('touchmove', this._boundHandle);
            this.target.addEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.addEventListener('mousedown', this._boundHandle);
            this.target.addEventListener('mouseup', this._boundHandle);
            this.target.addEventListener('mousemove', this._boundHandle);
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.addEventListener('wheel', this._boundWheel, wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);
        }
    }
    detach() {
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.removeEventListener('pointerdown', this._boundHandle);
            this.target.removeEventListener('pointerup', this._boundHandle);
            this.target.removeEventListener('pointermove', this._boundHandle);
            this.target.removeEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.removeEventListener('touchstart', this._boundHandle);
            this.target.removeEventListener('touchend', this._boundHandle);
            this.target.removeEventListener('touchmove', this._boundHandle);
            this.target.removeEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.removeEventListener('mousedown', this._boundHandle);
            this.target.removeEventListener('mouseup', this._boundHandle);
            this.target.removeEventListener('mousemove', this._boundHandle);
        }
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.removeEventListener('wheel', this._boundWheel);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel);
        }
    }
    /**
     * Take native pointer id and map it to index in active pointers
     * @param nativePointerId
     */
    _normalizePointerId(nativePointerId) {
        // Add to the the native pointer set id
        this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);
        // Native pointer ids in ascending order
        const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);
        // The index into sorted ids will be the new id, will always have an id
        const id = currentPointerIds.findIndex(p => p === nativePointerId);
        // Save the mapping so we can reverse it later
        this._activeNativePointerIdsToNormalized.set(nativePointerId, id);
        // ignore pointer because game isn't watching
        return id;
    }
    /**
     * Responsible for handling and parsing pointer events
     */
    _handle(ev) {
        ev.preventDefault();
        const eventCoords = new Map();
        let button;
        let pointerType;
        if (isTouchEvent(ev)) {
            button = PointerButton.Unknown;
            pointerType = PointerType.Touch;
            // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches[i];
                const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);
                const nativePointerId = i + 1;
                const pointerId = this._normalizePointerId(nativePointerId);
                this.currentFramePointerCoords.set(pointerId, coordinates);
                eventCoords.set(pointerId, coordinates);
            }
        }
        else {
            button = this._nativeButtonToPointerButton(ev.button);
            pointerType = PointerType.Mouse;
            const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);
            let nativePointerId = 1;
            if (isPointerEvent(ev)) {
                nativePointerId = ev.pointerId;
                pointerType = this._stringToPointerType(ev.pointerType);
            }
            const pointerId = this._normalizePointerId(nativePointerId);
            this.currentFramePointerCoords.set(pointerId, coordinates);
            eventCoords.set(pointerId, coordinates);
        }
        for (const [pointerId, coord] of eventCoords.entries()) {
            switch (ev.type) {
                case 'mousedown':
                case 'pointerdown':
                case 'touchstart':
                    this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, true);
                    break;
                case 'mouseup':
                case 'pointerup':
                case 'touchend':
                    this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, false);
                    break;
                case 'mousemove':
                case 'pointermove':
                case 'touchmove':
                    this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));
                    break;
                case 'touchcancel':
                case 'pointercancel':
                    this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));
                    break;
            }
        }
    }
    _handleWheel(ev) {
        // Should we prevent page scroll because of this event
        if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
            (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)) {
            ev.preventDefault();
        }
        const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));
        const world = this.engine.screen.screenToWorldCoordinates(screen);
        /**
         * A constant used to normalize wheel events across different browsers
         *
         * This normalization factor is pulled from
         * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
         */
        const ScrollWheelNormalizationFactor = -1 / 40;
        const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
        const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;
        const deltaZ = ev.deltaZ || 0;
        let deltaMode = WheelDeltaMode.Pixel;
        if (ev.deltaMode) {
            if (ev.deltaMode === 1) {
                deltaMode = WheelDeltaMode.Line;
            }
            else if (ev.deltaMode === 2) {
                deltaMode = WheelDeltaMode.Page;
            }
        }
        const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);
        this.currentFrameWheel.push(we);
    }
    /**
     * Triggers an excalibur pointer event in a world space pos
     *
     * Useful for testing pointers in excalibur
     * @param type
     * @param pos
     */
    triggerEvent(type, pos) {
        const page = this.engine.screen.worldToPageCoordinates(pos);
        // Send an event to the event receiver
        if (window.PointerEvent) {
            this._handle(new window.PointerEvent('pointer' + type, {
                pointerId: 0,
                clientX: page.x,
                clientY: page.y
            }));
        }
        else {
            // Safari hack
            this._handle(new window.MouseEvent('mouse' + type, {
                clientX: page.x,
                clientY: page.y
            }));
        }
        // Force update pointer system
        const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);
        const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);
        pointerSystem.preupdate();
        pointerSystem.update(transformEntities.getEntities());
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case NativePointerButton.NoButton:
                return PointerButton.NoButton;
            case NativePointerButton.Left:
                return PointerButton.Left;
            case NativePointerButton.Middle:
                return PointerButton.Middle;
            case NativePointerButton.Right:
                return PointerButton.Right;
            case NativePointerButton.Unknown:
                return PointerButton.Unknown;
            default:
                return fail(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return PointerType.Touch;
            case 'mouse':
                return PointerType.Mouse;
            case 'pen':
                return PointerType.Pen;
            default:
                return PointerType.Unknown;
        }
    }
}

;// CONCATENATED MODULE: ./Util/Fps.ts
class FpsSampler {
    constructor(options) {
        var _a;
        this._samplePeriod = 100;
        this._currentFrameTime = 0;
        this._frames = 0;
        this._previousSampleTime = 0;
        this._beginFrameTime = 0;
        this._fps = options.initialFps;
        this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;
        this._currentFrameTime = 1000 / options.initialFps;
        this._nowFn = options.nowFn;
        this._previousSampleTime = this._nowFn();
    }
    /**
     * Start of code block to sample FPS for
     */
    start() {
        this._beginFrameTime = this._nowFn();
    }
    /**
     * End of code block to sample FPS for
     */
    end() {
        this._frames++;
        const time = this._nowFn();
        this._currentFrameTime = time - this._beginFrameTime;
        if (time >= this._previousSampleTime + this._samplePeriod) {
            this._fps = (this._frames * 1000) / (time - this._previousSampleTime);
            this._previousSampleTime = time;
            this._frames = 0;
        }
    }
    /**
     * Return the currently sampled fps over the last sample period, by default every 100ms
     */
    get fps() {
        return this._fps;
    }
    /**
     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
     */
    get instant() {
        return 1000 / this._currentFrameTime;
    }
}

;// CONCATENATED MODULE: ./Util/Clock.ts


/**
 * Abstract Clock is the base type of all Clocks
 *
 * It has a few opinions
 * 1. It manages the calculation of what "elapsed" time means and thus maximum fps
 * 2. The default timing api is implemented in now()
 *
 * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever
 * method is unique to your clock implementation.
 */
class Clock {
    constructor(options) {
        var _a, _b, _c;
        this._onFatalException = () => { };
        this._maxFps = Infinity;
        this._lastTime = 0;
        this._elapsed = 1;
        this._scheduledCbs = [];
        this._totalElapsed = 0;
        this._options = options;
        this.tick = options.tick;
        this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;
        this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;
        this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;
        this.fpsSampler = new FpsSampler({
            initialFps: 60,
            nowFn: () => this.now()
        });
    }
    /**
     * Get the elapsed time for the last completed frame
     */
    elapsed() {
        return this._elapsed;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        return performance.now();
    }
    toTestClock() {
        const testClock = new TestClock({
            ...this._options,
            defaultUpdateMs: 16.6
        });
        return testClock;
    }
    toStandardClock() {
        const clock = new StandardClock({
            ...this._options
        });
        return clock;
    }
    setFatalExceptionHandler(handler) {
        this._onFatalException = handler;
    }
    /**
     * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]
     *
     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
     * stopped or paused.
     *
     * @param cb callback to fire
     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
     */
    schedule(cb, timeoutMs = 0) {
        // Scheduled based on internal elapsed time
        const scheduledTime = this._totalElapsed + timeoutMs;
        this._scheduledCbs.push([cb, scheduledTime]);
    }
    _runScheduledCbs() {
        // walk backwards to delete items as we loop
        for (let i = this._scheduledCbs.length - 1; i > -1; i--) {
            if (this._scheduledCbs[i][1] <= this._totalElapsed) {
                this._scheduledCbs[i][0]();
                this._scheduledCbs.splice(i, 1);
            }
        }
    }
    update(overrideUpdateMs) {
        try {
            this.fpsSampler.start();
            // Get the time to calculate time-elapsed
            const now = this.now();
            let elapsed = now - this._lastTime || 1; // first frame
            // Constrain fps
            const fpsInterval = (1000 / this._maxFps);
            // only run frame if enough time has elapsed
            if (elapsed >= fpsInterval) {
                let leftover = 0;
                if (fpsInterval !== 0) {
                    leftover = (elapsed % fpsInterval);
                    elapsed = elapsed - leftover; // shift elapsed to be "in phase" with the current loop fps
                }
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                // tick the mainloop and run scheduled callbacks
                this._elapsed = overrideUpdateMs || elapsed;
                this._totalElapsed += this._elapsed;
                this._runScheduledCbs();
                this.tick(overrideUpdateMs || elapsed);
                if (fpsInterval !== 0) {
                    this._lastTime = now - leftover;
                }
                else {
                    this._lastTime = now;
                }
                this.fpsSampler.end();
            }
        }
        catch (e) {
            this._onFatalException(e);
            this.stop();
        }
    }
}
/**
 * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()
 */
class StandardClock extends Clock {
    constructor(options) {
        super(options);
        this._running = false;
    }
    isRunning() {
        return this._running;
    }
    start() {
        if (this._running) {
            return;
        }
        this._running = true;
        const mainloop = () => {
            // stop the loop
            if (!this._running) {
                return;
            }
            try {
                // request next loop
                this._requestId = window.requestAnimationFrame(mainloop);
                this.update();
            }
            catch (e) {
                window.cancelAnimationFrame(this._requestId);
                throw e;
            }
        };
        // begin the first frame
        mainloop();
    }
    stop() {
        this._running = false;
    }
}
/**
 * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test
 */
class TestClock extends Clock {
    constructor(options) {
        super({
            ...options
        });
        this._logger = Logger.getInstance();
        this._running = false;
        this._currentTime = 0;
        this._updateMs = options.defaultUpdateMs;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        var _a;
        return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    isRunning() {
        return this._running;
    }
    start() {
        this._running = true;
    }
    stop() {
        this._running = false;
    }
    /**
     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
     * @param overrideUpdateMs
     */
    step(overrideUpdateMs) {
        const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;
        if (this._running) {
            // to be comparable to RAF this needs to be a full blown Task
            // For example, images cannot decode synchronously in a single step
            this.update(time);
            this._currentTime += time;
        }
        else {
            this._logger.warn('The clock is not running, no step will be performed');
        }
    }
    /**
     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
     * @param numberOfSteps
     * @param overrideUpdateMs
     */
    run(numberOfSteps, overrideUpdateMs) {
        for (let i = 0; i < numberOfSteps; i++) {
            this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);
        }
    }
}

// EXTERNAL MODULE: ./Util/Toaster.css
var Util_Toaster = __webpack_require__(7379);
;// CONCATENATED MODULE: ./Util/Toaster.ts

/**
 * The Toaster is only meant to be called from inside Excalibur to display messages to players
 */
class Toaster {
    constructor() {
        this._toasterCss = Util_Toaster/* default.toString */.Z.toString();
        this._isInitialized = false;
    }
    _initialize() {
        if (!this._isInitialized) {
            this._container = document.createElement('div');
            this._container.id = 'ex-toast-container';
            document.body.appendChild(this._container);
            this._isInitialized = true;
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._toasterCss;
            document.head.appendChild(this._styleBlock);
        }
    }
    dispose() {
        this._container.parentElement.removeChild(this._container);
        this._styleBlock.parentElement.removeChild(this._styleBlock);
        this._isInitialized = false;
    }
    _createFragment(message) {
        const toastMessage = document.createElement('span');
        toastMessage.innerText = message;
        return toastMessage;
    }
    /**
     * Display a toast message to a player
     * @param message Text of the message, messages may have a single "[LINK]" to influence placement
     * @param linkTarget Optionally specify a link location
     * @param linkName Optionally specify a name for that link location
     */
    toast(message, linkTarget, linkName) {
        this._initialize();
        const toast = document.createElement('div');
        toast.className = 'ex-toast-message';
        const messageFragments = message.split('[LINK]').map(message => this._createFragment(message));
        if (linkTarget) {
            const link = document.createElement('a');
            link.href = linkTarget;
            if (linkName) {
                link.innerText = linkName;
            }
            else {
                link.innerText = linkTarget;
            }
            messageFragments.splice(1, 0, link);
        }
        // Assembly message
        const finalMessage = document.createElement('div');
        messageFragments.forEach(message => {
            finalMessage.appendChild(message);
        });
        toast.appendChild(finalMessage);
        // Dismiss button
        const dismissBtn = document.createElement('button');
        dismissBtn.innerText = 'x';
        dismissBtn.addEventListener('click', () => {
            this._container.removeChild(toast);
        });
        toast.appendChild(dismissBtn);
        // Escape to dismiss
        const keydownHandler = (evt) => {
            if (evt.key === 'Escape') {
                try {
                    this._container.removeChild(toast);
                }
                catch (_a) {
                    // pass
                }
            }
            document.removeEventListener('keydown', keydownHandler);
        };
        document.addEventListener('keydown', keydownHandler);
        // Insert into container
        const first = this._container.firstChild;
        this._container.insertBefore(toast, first);
    }
}

;// CONCATENATED MODULE: ./Engine.ts



polyfill();


















/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends Class {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        super();
        /**
         * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.
         *
         * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than
         * one that bounces between 30fps and 60fps
         */
        this.maxFps = Number.POSITIVE_INFINITY;
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            Logger.getInstance().fatal(e);
        };
        this._toaster = new Toaster();
        this._timescale = 1.0;
        this._isInitialized = false;
        this._deferredGoTo = null;
        this._originalOptions = {};
        this._performanceThresholdTriggered = false;
        this._fpsSamples = [];
        this._loadingComplete = false;
        this._isReady = false;
        this._isReadyPromise = new Promise(resolve => {
            this._isReadyResolve = resolve;
        });
        /**
         * Returns the current frames elapsed milliseconds
         */
        this.currentFrameElapsedMs = 0;
        /**
         * Returns the current frame lag when in fixed update mode
         */
        this.currentFrameLagMs = 0;
        this._lagMs = 0;
        this._screenShotRequests = [];
        options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };
        this._originalOptions = options;
        Flags.freeze();
        // Initialize browser events facade
        this.browser = new BrowserEvents(window, document);
        // Check compatibility
        const detector = new Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = DisplayMode.FitScreen;
        }
        this._originalDisplayMode = displayMode;
        // Canvas 2D fallback can be flagged on
        let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');
        if (!useCanvasGraphicsContext) {
            // Attempt webgl first
            try {
                this.graphicsContext = new ExcaliburGraphicsContextWebGL({
                    canvasElement: this.canvas,
                    enableTransparency: this.enableCanvasTransparency,
                    smoothing: options.antialiasing,
                    backgroundColor: options.backgroundColor,
                    snapToPixel: options.snapToPixel,
                    useDrawSorting: options.useDrawSorting
                });
            }
            catch (e) {
                this._logger.warn(`Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. ` +
                    `Some features of Excalibur will not work in this mode. \n\n` +
                    'Read more about this issue at https://excaliburjs.com/docs/webgl');
                // fallback to canvas in case of failure
                useCanvasGraphicsContext = true;
            }
        }
        if (useCanvasGraphicsContext) {
            this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel,
                useDrawSorting: options.useDrawSorting
            });
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_d = options.pixelRatio) !== null && _d !== void 0 ? _d : null)
        });
        // Set default filtering based on antialiasing
        TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.maxFps = (_e = options.maxFps) !== null && _e !== void 0 ? _e : this.maxFps;
        this.fixedUpdateFps = (_f = options.fixedUpdateFps) !== null && _f !== void 0 ? _f : this.fixedUpdateFps;
        this.clock = new StandardClock({
            maxFps: this.maxFps,
            tick: this._mainloop.bind(this),
            onFatalException: (e) => this.onFatalException(e)
        });
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new Loader();
        this._loader.wireEngine(this);
        this.debug = new Debug(this);
        this._initialize(options);
        this.rootScene = this.currentScene = new Scene();
        this.addScene('root', this.rootScene);
        window.___EXCALIBUR_DEVTOOL = this;
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    /**
     * Hints the graphics context to truncate fractional world space coordinates
     */
    get snapToPixel() {
        return this.graphicsContext.snapToPixel;
    }
    ;
    set snapToPixel(shouldSnapToPixel) {
        this.graphicsContext.snapToPixel = shouldSnapToPixel;
    }
    ;
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    _monitorPerformanceThresholdAndTriggerFallback() {
        const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;
        let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;
        if (threshold === undefined) {
            threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;
        }
        if (showPlayerMessage === undefined) {
            showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;
        }
        if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {
            // Calculate Average fps for last X number of frames after start
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                this._fpsSamples.splice(0, 1);
            }
            this._fpsSamples.push(this.clock.fpsSampler.fps);
            let total = 0;
            for (let i = 0; i < this._fpsSamples.length; i++) {
                total += this._fpsSamples[i];
            }
            const average = total / this._fpsSamples.length;
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                if (average <= threshold.fps) {
                    this._performanceThresholdTriggered = true;
                    this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\n` +
                        'this might mean your browser doesn\'t have webgl enabled or hardware acceleration is unavailable.\n\n' +
                        'If in Chrome:\n' +
                        '  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.\n' +
                        '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"\n' +
                        'If in Firefox, visit about:config\n' +
                        '  * Ensure webgl.disabled = false\n' +
                        '  * Ensure webgl.force-enabled = true\n' +
                        '  * Ensure layers.acceleration.force-enabled = true\n\n' +
                        'Read more about this issue at https://excaliburjs.com/docs/performance');
                    if (showPlayerMessage) {
                        this._toaster.toast('Excalibur is encountering performance issues. ' +
                            'It\'s possible that your browser doesn\'t have hardware acceleration enabled. ' +
                            'Visit [LINK] for more information and potential solutions.', 'https://excaliburjs.com/docs/performance');
                    }
                    this.useCanvas2DFallback();
                    this.emit('fallbackgraphicscontext', this.graphicsContext);
                }
            }
        }
    }
    /**
     * Switches the engine's graphics context to the 2D Canvas.
     * @warning Some features of Excalibur will not work in this mode.
     */
    useCanvas2DFallback() {
        var _a, _b, _c;
        // Swap out the canvas
        const newCanvas = this.canvas.cloneNode(false);
        this.canvas.parentNode.replaceChild(newCanvas, this.canvas);
        this.canvas = newCanvas;
        const options = this._originalOptions;
        const displayMode = this._originalDisplayMode;
        // New graphics context
        this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
            canvasElement: this.canvas,
            enableTransparency: this.enableCanvasTransparency,
            smoothing: options.antialiasing,
            backgroundColor: options.backgroundColor,
            snapToPixel: options.snapToPixel,
            useDrawSorting: options.useDrawSorting
        });
        // Reset screen
        if (this.screen) {
            this.screen.dispose();
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,
            browser: this.browser,
            viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null)
        });
        this.screen.setCurrentCamera(this.currentScene.camera);
        // Reset pointers
        this.input.pointers.detach();
        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
        this.input.pointers = this.input.pointers.recreate(pointerTarget, this);
        this.input.pointers.init();
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof Scene) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
            return;
        }
        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
            this.scenes[this._deferredGoTo].add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof Scene) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     * @param data Optional data to send to the scene's onActivate method
     */
    goToScene(key, data) {
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoTo = key;
            return;
        }
        if (this.scenes[key]) {
            const previousScene = this.currentScene;
            const nextScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                const context = { engine: this, previousScene, nextScene };
                this.currentScene._deactivate.apply(this.currentScene, [context, nextScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(context, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = nextScene;
            this.screen.setCurrentCamera(nextScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            const context = { engine: this, previousScene, nextScene, data };
            this.currentScene._activate.apply(this.currentScene, [context, nextScene]);
            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(context, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
        this.input = {
            keyboard: new Keyboard(),
            pointers: new PointerEventReceiver(pointerTarget, this),
            gamepads: new Gamepads()
        };
        this.input.keyboard.init();
        this.input.pointers.init();
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
            if (this._deferredGoTo) {
                const deferredScene = this._deferredGoTo;
                this._deferredGoTo = null;
                this.goToScene(deferredScene);
            }
            else {
                this.goToScene('root');
            }
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (!this.ready) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.gamepads.update();
            return;
        }
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // Publish update event
        this._postupdate(delta);
        // Update input listeners
        this.input.keyboard.update();
        this.input.gamepads.update();
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new PreUpdateEvent(this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new PostUpdateEvent(this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        this.graphicsContext.beginDrawLifecycle();
        this.graphicsContext.clear();
        this._predraw(this.graphicsContext, delta);
        // Drawing nothing else while loading
        if (!this._isReady) {
            this._loader.canvas.draw(this.graphicsContext, 0, 0);
            this.graphicsContext.flush();
            return;
        }
        this.graphicsContext.backgroundColor = this.backgroundColor;
        this.currentScene.draw(this.graphicsContext, delta);
        this._postdraw(this.graphicsContext, delta);
        // Flush any pending drawings
        this.graphicsContext.flush();
        this.graphicsContext.endDrawLifecycle();
        this._checkForScreenShots();
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return this._loadingComplete;
    }
    get ready() {
        return this._isReady;
    }
    isReady() {
        return this._isReadyPromise;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     *
     * Note: start() only resolves AFTER the user has clicked the play button
     */
    async start(loader) {
        if (!this._compatible) {
            throw new Error('Excalibur is incompatible with your browser');
        }
        // Wire loader if we have it
        if (loader) {
            // Push the current user entered resolution/viewport
            this.screen.pushResolutionAndViewport();
            // Configure resolution for loader, it expects resolution === viewport
            this.screen.resolution = this.screen.viewport;
            this.screen.applyResolutionAndViewport();
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
        }
        // Start the excalibur clock which drives the mainloop
        // has started is a slight misnomer, it's really mainloop started
        this._logger.debug('Starting game clock...');
        this.browser.resume();
        this.clock.start();
        this._logger.debug('Game clock started');
        if (loader) {
            await this.load(this._loader);
            this._loadingComplete = true;
            // reset back to previous user resolution/viewport
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
        }
        this._loadingComplete = true;
        // Initialize before ready
        this._overrideInitialize(this);
        this._isReady = true;
        this._isReadyResolve();
        this.emit('start', new GameStartEvent(this));
        return this._isReadyPromise;
    }
    _mainloop(elapsed) {
        this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));
        const delta = elapsed * this.timescale;
        this.currentFrameElapsedMs = delta;
        // reset frame stats (reuse existing instances)
        const frameId = this.stats.prevFrame.id + 1;
        this.stats.currFrame.reset();
        this.stats.currFrame.id = frameId;
        this.stats.currFrame.delta = delta;
        this.stats.currFrame.fps = this.clock.fpsSampler.fps;
        GraphicsDiagnostics.clear();
        const beforeUpdate = this.clock.now();
        const fixedTimestepMs = 1000 / this.fixedUpdateFps;
        if (this.fixedUpdateFps) {
            this._lagMs += delta;
            while (this._lagMs >= fixedTimestepMs) {
                this._update(fixedTimestepMs);
                this._lagMs -= fixedTimestepMs;
            }
        }
        else {
            this._update(delta);
        }
        const afterUpdate = this.clock.now();
        this.currentFrameLagMs = this._lagMs;
        this._draw(delta);
        const afterDraw = this.clock.now();
        this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
        this.stats.currFrame.duration.draw = afterDraw - afterUpdate;
        this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
        this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));
        this.stats.prevFrame.reset(this.stats.currFrame);
        this._monitorPerformanceThresholdAndTriggerFallback();
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this.clock.isRunning()) {
            this.emit('stop', new GameStopEvent(this));
            this.browser.pause();
            this.clock.stop();
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's running status, Useful for checking whether engine is running or paused.
     */
    isRunning() {
        return this.clock.isRunning();
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
     */
    screenshot(preserveHiDPIResolution = false) {
        const screenShotPromise = new Promise((resolve) => {
            this._screenShotRequests.push({ preserveHiDPIResolution, resolve });
        });
        return screenShotPromise;
    }
    _checkForScreenShots() {
        // We must grab the draw buffer before we yield to the browser
        // the draw buffer is cleared after compositing
        // the reason for the asynchrony is setting `preserveDrawingBuffer: true`
        // forces the browser to copy buffers which can have a mass perf impact on mobile
        for (const request of this._screenShotRequests) {
            const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;
            const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;
            const screenshot = document.createElement('canvas');
            screenshot.width = finalWidth;
            screenshot.height = finalHeight;
            const ctx = screenshot.getContext('2d');
            ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);
            const result = new Image();
            const raw = screenshot.toDataURL('image/png');
            result.src = raw;
            request.resolve(result);
        }
        // Reset state
        this._screenShotRequests.length = 0;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    async load(loader) {
        try {
            await loader.load();
        }
        catch (e) {
            this._logger.error('Error loading resources, things may not behave properly', e);
            await Promise.resolve();
        }
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    useDrawSorting: true,
    configurePerformanceCanvas2DFallback: {
        allow: true,
        showPlayerMessage: false,
        threshold: { fps: 20, numberOfFrames: 100 }
    },
    canvasElementId: '',
    canvasElement: undefined,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue
};

;// CONCATENATED MODULE: ./Math/Index.ts













;// CONCATENATED MODULE: ./Debug/index.ts




;// CONCATENATED MODULE: ./Label.ts





/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label extends Actor {
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this._font = new Font();
        this._text = new Text({ text: '', font: this._font });
        const { text, pos, x, y, spriteFont, font, color } = options;
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this._text.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(GraphicsComponent);
        gfx.anchor = Vector.Zero;
        gfx.use(this._text);
    }
    get font() {
        return this._font;
    }
    set font(newFont) {
        this._font = newFont;
        this._text.font = newFont;
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        if (this._text) {
            this._text.color = color;
        }
    }
    get opacity() {
        return this._text.opacity;
    }
    set opacity(opacity) {
        this._text.opacity = opacity;
    }
    /**
     * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.
     */
    get spriteFont() {
        return this._spriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricMap.ts





class IsometricTile extends Entity {
    /**
     * Construct a new IsometricTile
     * @param x tile coordinate in x (not world position)
     * @param y tile coordinate in y (not world position)
     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
     * @param map reference to owning IsometricMap
     */
    constructor(x, y, graphicsOffset, map) {
        super([
            new TransformComponent(),
            new GraphicsComponent({
                offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : Vector.Zero,
                onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)
            }),
            new IsometricEntityComponent(map)
        ]);
        /**
         * Indicates whether this tile is solid
         */
        this.solid = false;
        this._tileBounds = new BoundingBox();
        this._graphics = [];
        /**
         * Tile colliders
         */
        this._colliders = [];
        this.x = x;
        this.y = y;
        this.map = map;
        this._transform = this.get(TransformComponent);
        this._isometricEntityComponent = this.get(IsometricEntityComponent);
        const halfTileWidth = this.map.tileWidth / 2;
        const halfTileHeight = this.map.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        // The x position shifts left with every y step
        const xPos = (this.x - this.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (this.x + this.y) * halfTileHeight;
        this._transform.pos = vec(xPos, yPos);
        this._isometricEntityComponent.elevation = 0;
        this._gfx = this.get(GraphicsComponent);
        this._gfx.visible = false; // start not visible
        const totalWidth = this.map.tileWidth;
        const totalHeight = this.map.tileHeight;
        // initial guess at gfx bounds based on the tile
        const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));
        this._gfx.localBounds = this._tileBounds = new BoundingBox({
            left: -totalWidth / 2,
            top: -totalHeight,
            right: totalWidth / 2,
            bottom: totalHeight
        }).translate(offset);
    }
    getGraphics() {
        return this._graphics;
    }
    /**
     * Tile graphics
     */
    addGraphic(graphic) {
        this._graphics.push(graphic);
        this._gfx.visible = true;
        this._gfx.localBounds = this._recalculateBounds();
    }
    _recalculateBounds() {
        let bounds = this._tileBounds.clone();
        for (const graphic of this._graphics) {
            const offset = vec(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));
            bounds = bounds.combine(graphic.localBounds.translate(offset));
        }
        return bounds;
    }
    removeGraphic(graphic) {
        const index = this._graphics.indexOf(graphic);
        if (index > -1) {
            this._graphics.splice(index, 1);
        }
        this._gfx.localBounds = this._recalculateBounds();
    }
    clearGraphics() {
        this._graphics.length = 0;
        this._gfx.visible = false;
        this._gfx.localBounds = this._recalculateBounds();
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a collider to the IsometricTile
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the IsometricTile
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the IsometricTile
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    /**
     * Returns the top left corner of the [[IsometricTile]] in world space
     */
    get pos() {
        return this.map.tileToWorld(vec(this.x, this.y));
    }
    /**
     * Returns the center of the [[IsometricTile]]
     */
    get center() {
        return this.pos.add(vec(0, this.map.tileHeight / 2));
    }
    draw(gfx, _elapsed) {
        const halfTileWidth = this.map.tileWidth / 2;
        gfx.save();
        // shift left origin to corner of map, not the left corner of the first sprite
        gfx.translate(-halfTileWidth, 0);
        for (const graphic of this._graphics) {
            graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));
        }
        gfx.restore();
    }
}
/**
 * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur
 *
 * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.
 * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.
 *
 * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given
 * your art assets.
 */
class IsometricMap extends Entity {
    constructor(options) {
        super([
            new TransformComponent(),
            new BodyComponent({
                type: CollisionType.Fixed
            }),
            new ColliderComponent(),
            new DebugGraphicsComponent((ctx) => this.debug(ctx), false)
        ], options.name);
        /**
         * Render the tile graphic from the top instead of the bottom
         *
         * default is `false` meaning rendering from the bottom
         */
        this.renderFromTopOfGraphic = false;
        this.graphicsOffset = vec(0, 0);
        this._collidersDirty = false;
        this._originalOffsets = new WeakMap();
        const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;
        this.transform = this.get(TransformComponent);
        if (pos) {
            this.transform.pos = pos;
        }
        this.collider = this.get(ColliderComponent);
        if (this.collider) {
            this.collider.set(this._composite = new CompositeCollider([]));
        }
        this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;
        this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.columns = width;
        this.rows = height;
        this.tiles = new Array(width * height);
        // build up tile representation
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const tile = new IsometricTile(x, y, this.graphicsOffset, this);
                this.tiles[x + y * width] = tile;
                this.addChild(tile);
                // TODO row/columns helpers
            }
        }
    }
    update() {
        if (this._collidersDirty) {
            this.updateColliders();
            this._collidersDirty = false;
        }
    }
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    _getOrSetColliderOriginalOffset(collider) {
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return this._originalOffsets.get(collider);
        }
    }
    updateColliders() {
        this._composite.clearColliders();
        const pos = this.get(TransformComponent).pos;
        for (const tile of this.tiles) {
            if (tile.solid) {
                for (const collider of tile.getColliders()) {
                    const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                    collider.offset = this.tileToWorld(vec(tile.x, tile.y))
                        .sub(pos)
                        .add(originalOffset)
                        .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing
                    collider.owner = this;
                    this._composite.addCollider(collider);
                }
            }
        }
        this.collider.update();
    }
    /**
     * Convert world space coordinates to the tile x, y coordinate
     * @param worldCoordinate
     */
    worldToTile(worldCoordinate) {
        worldCoordinate = worldCoordinate.sub(this.transform.globalPos);
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        return vec(~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2), ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));
    }
    /**
     * Given a tile coordinate, return the top left corner in world space
     * @param tileCoordinate
     */
    tileToWorld(tileCoordinate) {
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // The x position shifts left with every y step
        const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;
        return vec(xPos, yPos).add(this.transform.pos);
    }
    /**
     * Returns the [[IsometricTile]] by its x and y coordinates
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the [[IsometricTile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const tileCoord = this.worldToTile(point);
        const tile = this.getTile(tileCoord.x, tileCoord.y);
        return tile;
    }
    _getMaxZIndex() {
        let maxZ = Number.NEGATIVE_INFINITY;
        for (const tile of this.tiles) {
            const currentZ = tile.get(TransformComponent).z;
            if (currentZ > maxZ) {
                maxZ = currentZ;
            }
        }
        return maxZ;
    }
    /**
     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
     * @param gfx
     */
    debug(gfx) {
        gfx.save();
        gfx.z = this._getMaxZIndex() + 0.5;
        for (let y = 0; y < this.rows + 1; y++) {
            const left = this.tileToWorld(vec(0, y));
            const right = this.tileToWorld(vec(this.columns, y));
            gfx.drawLine(left, right, Color.Red, 2);
        }
        for (let x = 0; x < this.columns + 1; x++) {
            const top = this.tileToWorld(vec(x, 0));
            const bottom = this.tileToWorld(vec(x, this.rows));
            gfx.drawLine(top, bottom, Color.Red, 2);
        }
        for (const tile of this.tiles) {
            gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);
        }
        gfx.restore();
    }
}

;// CONCATENATED MODULE: ./TileMap/index.ts





;// CONCATENATED MODULE: ./Actions/Action/ActionSequence.ts

/**
 * Action that can represent a sequence of actions, this can be useful in conjunction with
 * [[ParallelActions]] to run multiple sequences in parallel.
 */
class ActionSequence {
    constructor(entity, actionBuilder) {
        this._stopped = false;
        this._sequenceBuilder = actionBuilder;
        this._sequenceContext = new ActionContext(entity);
        this._actionQueue = this._sequenceContext.getQueue();
        this._sequenceBuilder(this._sequenceContext);
    }
    update(delta) {
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || this._actionQueue.isComplete();
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._stopped = false;
        this._actionQueue.reset();
    }
    clone(entity) {
        return new ActionSequence(entity, this._sequenceBuilder);
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ParallelActions.ts
/**
 * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time
 */
class ParallelActions {
    constructor(parallelActions) {
        this._actions = parallelActions;
    }
    update(delta) {
        for (let i = 0; i < this._actions.length; i++) {
            this._actions[i].update(delta);
        }
    }
    isComplete(entity) {
        return this._actions.every(a => a.isComplete(entity));
    }
    reset() {
        this._actions.forEach(a => a.reset());
    }
    stop() {
        this._actions.forEach(a => a.stop());
    }
}

;// CONCATENATED MODULE: ./Actions/Index.ts


























;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();

;// CONCATENATED MODULE: ./Collision/Index.ts





























;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}

;// CONCATENATED MODULE: ./Interfaces/Index.ts








;// CONCATENATED MODULE: ./Resources/Sound/Index.ts




;// CONCATENATED MODULE: ./Resources/Gif.ts






/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = Color.Magenta, bustCache = true) {
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._resource = new Resource(path, 'arraybuffer', bustCache);
        this._transparentColor = color;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    async load() {
        const arraybuffer = await this._resource.load();
        this._stream = new Stream(arraybuffer);
        this._gif = new ParseGif(this._stream, this._transparentColor);
        const images = this._gif.images.map(i => new ImageSource(i.src, false));
        // Load all textures
        await Promise.all(images.map(t => t.load()));
        return this.data = this._textures = images;
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        const sprite = this._textures[id].toSprite();
        return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._textures.map((image) => {
            return image.toSprite();
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
        const spriteSheet = this.toSpriteSheet();
        const length = spriteSheet.sprites.length;
        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = Color.Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}

;// CONCATENATED MODULE: ./Resources/Index.ts




;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts











;// CONCATENATED MODULE: ./Graphics/Line.ts



class Line extends Graphic {
    constructor(options) {
        super();
        this.color = Color.Black;
        this.thickness = 1;
        const { start, end, color, thickness } = options;
        this.start = start;
        this.end = end;
        this.color = color !== null && color !== void 0 ? color : this.color;
        this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;
        const { width, height } = BoundingBox.fromPoints([start, end]);
        this.width = width;
        this.height = height;
    }
    _drawImage(ctx, _x, _y) {
        ctx.drawLine(this.start, this.end, this.color, this.thickness);
    }
    clone() {
        return new Line({
            start: this.start,
            end: this.end,
            color: this.color,
            thickness: this.thickness
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Polygon.ts



/**
 * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]
 *
 * Polygons default to [[ImageFiltering.Blended]]
 */
class Polygon extends Raster {
    constructor(options) {
        super(options);
        this.points = options.points;
        this.filtering = ImageFiltering.Blended;
        this.rasterize();
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return vec(minX, minY);
    }
    clone() {
        return new Polygon({
            points: this.points.map((p) => p.clone()),
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/index.ts
// Graphics







// Graphics ECS





// Raster graphics













// Post Processor






// Rendering





// Util



;// CONCATENATED MODULE: ./Input/Index.ts
/**
 * @module
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */















;// CONCATENATED MODULE: ./Util/Index.ts







;// CONCATENATED MODULE: ./Util/Semaphore.ts

class AsyncWaitQueue {
    constructor() {
        // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e
        this._queue = [];
    }
    get length() {
        return this._queue.length;
    }
    enqueue() {
        const future = new Future();
        this._queue.push(future);
        return future.promise;
    }
    dequeue(value) {
        const future = this._queue.shift();
        future.resolve(value);
    }
}
/**
 * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`
 *
 * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work
 * around browser limitations like max Image.decode() calls in chromium being 256.
 */
class Semaphore {
    constructor(_count) {
        this._count = _count;
        this._waitQueue = new AsyncWaitQueue();
    }
    get count() {
        return this._count;
    }
    get waiting() {
        return this._waitQueue.length;
    }
    async enter() {
        if (this._count !== 0) {
            this._count--;
            return Promise.resolve();
        }
        return this._waitQueue.enqueue();
    }
    exit(count = 1) {
        if (count === 0) {
            return;
        }
        while (count !== 0 && this._waitQueue.length !== 0) {
            this._waitQueue.dequeue(null);
            count--;
        }
        this._count += count;
    }
}

;// CONCATENATED MODULE: ./index.ts
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.27.0";

polyfill();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.






























// ex.Events namespace


// ex.Input namespace




// ex.Util namespaces
















// ex.Deprecated
// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=excalibur.js.map